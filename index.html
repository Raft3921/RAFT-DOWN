<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ラフトの世界 - エディタ</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #0c0f1a;
      font-family: "Segoe UI", sans-serif;
      color: #e9f1ff;
      overflow: hidden;
    }
    .editor-shell {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      position: relative;
    }
    header {
      padding: 12px 18px;
      background: rgba(7, 10, 20, 0.85);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 16px;
    }
    body.moving header {
      visibility: hidden;
      pointer-events: none;
    }
    body.moving .palette-container,
    body.moving .move-panel {
      opacity: 0;
      pointer-events: none;
    }
    body.resizing .palette-container {
      backdrop-filter: none;
      box-shadow: none;
      transition: none;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    header .hint {
      font-size: 13px;
      color: rgba(233, 241, 255, 0.75);
      align-self: center;
    }
    .toolbar {
      display: flex;
      gap: 12px;
      justify-self: end;
    }
    .toolbar button {
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid rgba(111, 168, 255, 0.4);
      background: rgba(29, 48, 88, 0.8);
      color: #e9f1ff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s, border 0.15s;
      
    }
    .toolbar button:hover {
      transform: translateY(-1px);
      border-color: rgba(111, 168, 255, 0.8);
      box-shadow: 0 6px 12px rgba(58, 116, 214, 0.28);
    }
    .toolbar button.active {
      border-color: rgba(135, 190, 255, 0.9);
      background: rgba(48, 82, 146, 0.9);
      box-shadow: inset 0 0 12px rgba(120, 178, 255, 0.45);
    }
    canvas {
      flex: 1 1 auto;
      width: 100%;
      display: block;
      image-rendering: pixelated;
      background: #040712;
      cursor: crosshair;
    }
    .move-panel {
  position: absolute;
  right: 20px;
  top: 80px;
  background: rgba(10,20,40,0.9);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 12px;
  z-index: 10;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.move-panel.hidden { display: none; }
.move-row { display: flex; justify-content: center; gap: 8px; }
.move-panel button {
  padding: 6px 12px;
  border-radius: 8px;
  background: rgba(50,80,150,0.8);
  color: #fff;
  border: none;
  cursor: pointer;
}
.move-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
  font-size: 12px;
  color: rgba(233, 241, 255, 0.8);
}
.move-header button {
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(80, 110, 170, 0.9);
  border: none;
  font-size: 11px;
  cursor: pointer;
  white-space: nowrap;
}
.move-header button:hover {
  filter: brightness(1.1);
}


    .palette-container {
      position: absolute;
      left: 50%;
      bottom: 24px;
      transform: translateX(-50%);
      width: min(960px, calc(100% - 48px));
      background: rgba(9, 12, 24, 0.86);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 40px rgba(10, 16, 35, 0.55);
      padding: 16px 20px 14px;
      border-radius: 18px;
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
      z-index: 2;
      min-width: 260px;
      min-height: 140px;
      overflow: hidden;
    }
    .palette-container.floating {
      transform: none;
      left: 24px;
      top: 24px;
      bottom: auto;
    }
    .palette-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: grab;
      user-select: none;
    }
    .palette-header:active {
      cursor: grabbing;
    }
    .palette-resizer {
      position: absolute;
      right: 6px;
      bottom: 6px;
      width: 18px;
      height: 18px;
      cursor: nwse-resize;
      border-radius: 4px;
      background:
        linear-gradient(135deg, rgba(255,255,255,0.15) 25%, transparent 25%),
        linear-gradient(135deg, rgba(255,255,255,0.3) 25%, transparent 25%);
      background-size: 6px 6px;
      background-position: 0 0, 3px 3px;
      opacity: 0.65;
    }
    .palette-label {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.04em;
      color: rgba(233, 241, 255, 0.8);
    }
    .palette-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .layer-tabs {
      display: inline-flex;
      gap: 8px;
      background: rgba(16, 24, 42, 0.6);
      border-radius: 999px;
      padding: 4px;
    }
    .layer-tabs button {
      padding: 6px 14px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: rgba(233, 241, 255, 0.75);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .layer-tabs button.active {
      background: rgba(90, 135, 220, 0.6);
      color: #fff;
      box-shadow: 0 0 0 1px rgba(120, 170, 255, 0.45);
    }
    .palette-tabs {
      display: inline-flex;
      gap: 8px;
      background: rgba(16, 24, 42, 0.6);
      border-radius: 999px;
      padding: 4px;
    }
    .palette-tabs button {
      padding: 6px 14px;
      border-radius: 999px;
      border: none;
      background: transparent;
      color: rgba(233, 241, 255, 0.75);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }
    .palette-tabs button.active {
      background: rgba(90, 135, 220, 0.35);
      color: #fff;
      box-shadow: 0 0 0 1px rgba(120, 170, 255, 0.45);
    }
    .palette {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      flex: 1 1 auto;
      min-height: 80px;
      min-height: 0;
      overflow-y: auto;
      padding-right: 6px;
    }
    .palette button {
      display: grid;
      grid-template-columns: 36px 1fr;
      gap: 8px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(12, 18, 34, 0.8);
      color: #e9f1ff;
      font-size: 13px;
      cursor: pointer;
      transition: border 0.18s, background 0.18s, box-shadow 0.18s;
      text-align: left;
    }
    .palette button img {
      width: 36px;
      height: 36px;
      image-rendering: pixelated;
      justify-self: center;
    }
    .palette button.active {
      border: 1px solid #6fa8ff;
      background: rgba(28, 52, 110, 0.85);
      box-shadow: inset 0 0 18px rgba(111, 168, 255, 0.22);
    }
    .palette button span {
      pointer-events: none;
      line-height: 1.4;
    }
    .palette::-webkit-scrollbar {
      width: 6px;
    }
    .palette::-webkit-scrollbar-track {
      background: transparent;
    }
    .palette::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.16);
      border-radius: 999px;
    }
    .toast {
      position: absolute;
      top: -52px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(28, 52, 110, 0.92);
      border: 1px solid rgba(111, 168, 255, 0.35);
      color: #e9f1ff;
      font-size: 13px;
      letter-spacing: 0.03em;
      box-shadow: 0 10px 20px rgba(37, 68, 142, 0.4);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }
    .toast.visible {
      opacity: 1;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 24px;
    }
    .modal-backdrop.visible {
      display: flex;
    }
    .modal {
      width: min(560px, 100%);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(9, 12, 24, 0.92);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(12px);
      padding: 16px 18px 14px;
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .modal-title {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.04em;
      margin: 0;
    }
    .modal-close {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(111, 168, 255, 0.35);
      background: rgba(29, 48, 88, 0.8);
      color: #e9f1ff;
      font-size: 12px;
      cursor: pointer;
    }
    .modal-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(12, 18, 34, 0.6);
    }
    .modal-row label {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      width: 100%;
      cursor: pointer;
      user-select: none;
    }
    .modal-row input[type="checkbox"] {
      margin-top: 2px;
      transform: scale(1.1);
    }
    .modal-row .modal-row-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .modal-row .modal-row-text .primary {
      font-size: 13px;
      font-weight: 700;
      color: #e9f1ff;
    }
    .modal-row .modal-row-text .secondary {
      font-size: 12px;
      color: rgba(233, 241, 255, 0.75);
      line-height: 1.4;
    }
    .help-modal {
      width: min(720px, calc(100% - 32px));
    }
    .help-list {
      display: grid;
      gap: 10px;
    }
    .help-item {
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(12, 18, 34, 0.6);
      font-size: 13px;
      line-height: 1.5;
    }
    .help-item strong {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .help-footer {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: rgba(233, 241, 255, 0.75);
    }
  </style>
</head>
<body>
  
  <div class="editor-shell">
    <header>
      <h1>ラフトの世界 - エディタ</h1>
      <div class="hint">WASDで移動・クリックでブロック配置・Shiftで加速・0番は空ブロック</div>
      <div class="toolbar">
        <button id="settingsBtn">設定</button>
        <button id="resetCameraBtn">カメラリセット</button>
        <button id="clearLocalBtn">ローカル自動保存クリア</button>
        <button id="saveLocalBtn">ローカル保存</button>
        <button id="uploadBtn">アップロード</button>
        <button id="downloadBtn">ダウンロード</button>
        <input type="file" id="uploadInput" accept=".json,.js,application/json" hidden />
      </div>
    </header>
    <div id="settingsModal" class="modal-backdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
        <div class="modal-header">
          <h2 id="settingsTitle" class="modal-title">設定</h2>
          <button id="settingsCloseBtn" class="modal-close" type="button">閉じる</button>
        </div>
        <div class="modal-row">
          <label>
            <input id="useLocalAutosaveOnLoad" type="checkbox" />
            <span class="modal-row-text">
              <span class="primary">起動時にローカル保存データを読み込む</span>
              <span class="secondary">ONの場合、前回の作業途中のデータを優先して復元します。OFFの場合、terrain-data.js / terrain.json を優先します。</span>
            </span>
          </label>
        </div>
      </div>
    </div>
    <div id="saveHelpModal" class="modal-backdrop" aria-hidden="true">
      <div class="modal help-modal" role="dialog" aria-modal="true" aria-labelledby="saveHelpTitle">
        <div class="modal-header">
          <h2 id="saveHelpTitle" class="modal-title">保存と読み込みの使い方</h2>
          <button id="saveHelpCloseBtn" class="modal-close" type="button">閉じる</button>
        </div>
        <div class="help-list">
          <div class="help-item">
            <strong>ダウンロード</strong>
            terrain.json と terrain-data.js を保存します。保存先を選ぶダイアログが表示されます。
          </div>
          <div class="help-item">
            <strong>ローカル保存</strong>
            今の作業をブラウザのローカルストレージへ即保存します。再読み込み時の復元用です。
          </div>
          <div class="help-item">
            <strong>ローカル自動保存クリア</strong>
            これまでのローカル自動保存データを削除します。復元をやり直したい時に使います。
          </div>
          <div class="help-item">
            <strong>アップロード</strong>
            terrain.json / terrain-data.js を読み込み、編集を再開します。
          </div>
        </div>
        <label class="help-footer">
          <input id="saveHelpDontShow" type="checkbox" />
          次から表示しない
        </label>
      </div>
    </div>
    <canvas id="editorCanvas" width="1280" height="720"></canvas>
  <div class="palette-container" id="paletteContainer">
      <div class="palette-header">
        <div class="palette-label">ブロックスロット</div>
        <button id="moveWorldBtn">ワールド移動</button>
         <button id="selectToolBtn">選択ツール</button>
        <div id="movePanel" class="move-panel hidden">
    <!-- ★ 追加: モード表示 & 選択解除 -->
    <div class="move-header">
      <span id="moveTargetLabel">対象: ワールド全体</span>
      <button id="clearSelectionBtn" type="button">選択解除</button>
    </div>
  <div class="move-row">
    <button data-dir="up">↑ 上へ</button>
  </div>
  <div class="move-row">
    <button data-dir="left">← 左へ</button>
    <button data-dir="right">右へ →</button>
  </div>
  <div class="move-row">
    <button data-dir="down">↓ 下へ</button>
  </div>
</div>
        <div class="palette-controls">
          <div class="layer-tabs" id="layerTabs"></div>
          <div class="palette-tabs" id="paletteTabs"></div>
        </div>
  </div>
  <div class="palette" id="palette"></div>
  <div id="toast" class="toast"></div>
  <div class="palette-resizer" id="paletteResizer" aria-hidden="true"></div>
</div>
</div>
<script>

// === global-safe poison anim vars (avoid TDZ) ===
(function(){
  if (!('window.poisonImages' in window) || !Array.isArray(window.poisonImages)) {
    window.poisonImages = [];
  }
  if (!('window.poisonAnim' in window) || typeof window.poisonAnim !== 'object' || window.poisonAnim === null) {
    window.poisonAnim = { index: 0, lastTime: performance.now(), interval: 140 };
  }
})();
// === end global-safe poison anim vars ===
const DISABLE_EXTERNAL_ASSET_MAP = true;
</script>
<script>
  const AUTOSAVE_STORAGE_KEY = 'raft_autosave';
  if (typeof window !== 'undefined') {
    window.__RAFT_AUTOSAVE_KEY = AUTOSAVE_STORAGE_KEY;
  }
    const PREF_USE_LOCAL_AUTOSAVE_ON_LOAD_KEY = 'raft_editor_pref_use_local_autosave_on_load';
    const PREF_PALETTE_PANEL_STATE_KEY = 'raft_editor_palette_panel_state_v1';
    const PREF_CAMERA_STATE_KEY = 'raft_editor_camera_state_v1';
    const PREF_SHOW_SAVE_HELP_KEY = 'raft_editor_pref_show_save_help';
    const DEFAULT_CAMERA_X = 0;
    const DEFAULT_CAMERA_Y = 4000;

  function readBooleanPref(key, defaultValue) {
    if (typeof window === 'undefined' || !window.localStorage) return defaultValue;
    try {
      const value = window.localStorage.getItem(key);
      if (value === null) return defaultValue;
      if (value === '1' || value === 'true') return true;
      if (value === '0' || value === 'false') return false;
      return defaultValue;
    } catch (_) {
      return defaultValue;
    }
  }

    function writeBooleanPref(key, value) {
      if (typeof window === 'undefined' || !window.localStorage) return;
      try {
        window.localStorage.setItem(key, value ? '1' : '0');
      } catch (_) {
        /* noop */
      }
    }

    function readJsonPref(key, fallbackValue) {
      if (typeof window === 'undefined' || !window.localStorage) return fallbackValue;
      try {
        const raw = window.localStorage.getItem(key);
        if (!raw) return fallbackValue;
        const parsed = JSON.parse(raw);
        return parsed ?? fallbackValue;
      } catch (_) {
        return fallbackValue;
      }
    }

    function writeJsonPref(key, value) {
      if (typeof window === 'undefined' || !window.localStorage) return;
      try {
        window.localStorage.setItem(key, JSON.stringify(value));
      } catch (_) {
        /* noop */
      }
    }

    function openHandleDb() {
      if (typeof window === 'undefined' || !window.indexedDB) {
        return Promise.reject(new Error('indexedDB unavailable'));
      }
      return new Promise((resolve, reject) => {
        const request = window.indexedDB.open('raft_editor_handles', 1);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains('handles')) {
            db.createObjectStore('handles');
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function readHandleFromDb(key) {
      const db = await openHandleDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('handles', 'readonly');
        const store = tx.objectStore('handles');
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    async function writeHandleToDb(key, value) {
      const db = await openHandleDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('handles', 'readwrite');
        const store = tx.objectStore('handles');
        const req = store.put(value, key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    function initEditor(assetMap, initialMapData) {
        const moveWorldBtn = document.getElementById('moveWorldBtn');
    const movePanel = document.getElementById('movePanel');

    function dirLabel(dir){
      return {up:'上',down:'下',left:'左',right:'右'}[dir] || '';
    }

    // ★ 選択の有無判定
    function hasSelection() {
      return !!selection;
    }

    // ★ ワールド全体移動（従来の処理）
    function shiftWorld(dir) {
      const shiftArray = (arr, dir) => {
        if (dir === 'up') arr.shift(), arr.push(new Array(COLS).fill(0));
        if (dir === 'down') arr.pop(), arr.unshift(new Array(COLS).fill(0));
        if (dir === 'left') arr.forEach(r => { r.shift(); r.push(0); });
        if (dir === 'right') arr.forEach(r => { r.pop(); r.unshift(0); });
      };
      [map, backgroundMap, frontMap, debugMap,
       flipH, flipV, backgroundFlipH, backgroundFlipV,
       frontFlipH, frontFlipV, debugFlipH, debugFlipV].forEach(layer => shiftArray(layer, dir));
      cachedBounds.dirty = true;
      rebuildAllSparseIndexes();
      markDirty();
    }

    // ★ 選択範囲のみ移動（アクティブレイヤー単位）
    function shiftSelection(dir) {
      if (!selection) return;

      const layerRefs = (() => {
        if (activeLayer === 'background') {
          const layer = backgroundLayers[activeBackgroundIndex];
          return layer ? { map: layer.map, flipH: layer.flipH, flipV: layer.flipV } : null;
        }
        if (activeLayer === 'front') {
          const layer = frontLayers[activeFrontIndex];
          return layer ? { map: layer.map, flipH: layer.flipH, flipV: layer.flipV } : null;
        }
        if (activeLayer === 'debug') {
          return { map: debugMap, flipH: debugFlipH, flipV: debugFlipV };
        }
        return { map, flipH, flipV };
      })();
      if (!layerRefs) {
        showToast('このレイヤーは移動できません');
        return;
      }

      let dRow = 0, dCol = 0;
      if (dir === 'up') dRow = -1;
      if (dir === 'down') dRow = 1;
      if (dir === 'left') dCol = -1;
      if (dir === 'right') dCol = 1;

      const { minRow, maxRow, minCol, maxCol } = selection;
      const height = maxRow - minRow + 1;
      const width = maxCol - minCol + 1;

      const newMinRow = minRow + dRow;
      const newMaxRow = maxRow + dRow;
      const newMinCol = minCol + dCol;
      const newMaxCol = maxCol + dCol;

      // 端で止める
      if (newMinRow < 0 || newMaxRow >= ROWS || newMinCol < 0 || newMaxCol >= COLS) {
        showToast('これ以上その方向へ移動できません');
        return;
      }

      function shiftLayer(layer, flipHLayer, flipVLayer) {
        const temp = Array.from({length: height}, () => new Array(width).fill(0));
        const tempFH = flipHLayer ? Array.from({length: height}, () => new Array(width).fill(false)) : null;
        const tempFV = flipVLayer ? Array.from({length: height}, () => new Array(width).fill(false)) : null;

        // コピー
        for (let r = 0; r < height; r++) {
          for (let c = 0; c < width; c++) {
            const srcRow = minRow + r;
            const srcCol = minCol + c;
            temp[r][c] = layer[srcRow][srcCol];
            if (flipHLayer) tempFH[r][c] = flipHLayer[srcRow][srcCol];
            if (flipVLayer) tempFV[r][c] = flipVLayer[srcRow][srcCol];
          }
        }

        // 元の位置を空に
        for (let r = 0; r < height; r++) {
          for (let c = 0; c < width; c++) {
            const srcRow = minRow + r;
            const srcCol = minCol + c;
            layer[srcRow][srcCol] = 0;
            if (flipHLayer) flipHLayer[srcRow][srcCol] = false;
            if (flipVLayer) flipVLayer[srcRow][srcCol] = false;
          }
        }

        // 新しい位置に書き込み
        for (let r = 0; r < height; r++) {
          for (let c = 0; c < width; c++) {
            const dstRow = newMinRow + r;
            const dstCol = newMinCol + c;
            layer[dstRow][dstCol] = temp[r][c];
            if (flipHLayer) flipHLayer[dstRow][dstCol] = tempFH[r][c];
            if (flipVLayer) flipVLayer[dstRow][dstCol] = tempFV[r][c];
          }
        }
      }

      shiftLayer(layerRefs.map, layerRefs.flipH, layerRefs.flipV);

      // デバッグのスポーンマーカー更新
      if (layerRefs.map === debugMap) {
        refreshDebugSpecialMarkers();
      }

      // 選択範囲も新しい位置に更新
      selection = {
        minRow: newMinRow,
        maxRow: newMaxRow,
        minCol: newMinCol,
        maxCol: newMaxCol
      };
      updateMoveTargetLabel();
      cachedBounds.dirty = true;
      rebuildActiveLayerSparseIndex();
      markDirty();
      requestRender();
    }

    if (moveWorldBtn && movePanel) {
      moveWorldBtn.addEventListener('click', () => {
        movePanel.classList.toggle('hidden');
      });

      movePanel.querySelectorAll('button[data-dir]').forEach(btn => {
        btn.addEventListener('click', () => {
          const dir = btn.dataset.dir;
          if (hasSelection()) {
            shiftSelection(dir);
            showToast(`選択範囲を${dirLabel(dir)}へ移動しました`);
          } else {
            shiftWorld(dir);
            showToast(`ワールドを${dirLabel(dir)}へ移動しました`);
          }
        });
      });
    }


    const TILE_SIZE = 48;
  const COLS = 1000;
  const ROWS = 500;
  const CAMERA_SPEED = 12;
    const CAMERA_SPEED_FAST = 32;
    const RENDER_SCALE = 0.5;

    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const paletteElement = document.getElementById('palette');
    const toastElement = document.getElementById('toast');
    const uploadButton = document.getElementById('uploadBtn');
    const downloadButton = document.getElementById('downloadBtn');
    const uploadInput = document.getElementById('uploadInput');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const settingsCloseBtn = document.getElementById('settingsCloseBtn');
    const useLocalAutosaveOnLoadCheckbox = document.getElementById('useLocalAutosaveOnLoad');
    const clearLocalBtn = document.getElementById('clearLocalBtn');
    const resetCameraBtn = document.getElementById('resetCameraBtn');
    const saveLocalBtn = document.getElementById('saveLocalBtn');
    const saveHelpModal = document.getElementById('saveHelpModal');
    const saveHelpCloseBtn = document.getElementById('saveHelpCloseBtn');
    const saveHelpDontShow = document.getElementById('saveHelpDontShow');
    const selectToolBtn = document.getElementById('selectToolBtn');
    const moveTargetLabel = document.getElementById('moveTargetLabel');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');
    const paletteContainer = document.getElementById('paletteContainer');
    const paletteResizer = document.getElementById('paletteResizer');
    let selection = null;     // {minRow,maxRow,minCol,maxCol} か null
    let selectionRect = null; // ドラッグ中の仮選択 {startRow,startCol,endRow,endCol}
    let isDraggingPalette = false;
    let isResizingPalette = false;
    let paletteDragOffsetX = 0;
    let paletteDragOffsetY = 0;
    let paletteStartWidth = 0;
    let paletteStartHeight = 0;
    let paletteStartX = 0;
    let paletteStartY = 0;
    let paletteResizeFrame = null;
    let pendingResizeWidth = 0;
    let pendingResizeHeight = 0;
    let paletteSaveTimer = null;
        // ★ 選択状態の表示更新
    function updateMoveTargetLabel() {
      if (!moveTargetLabel) return;
      if (selection) {
        const w = selection.maxCol - selection.minCol + 1;
        const h = selection.maxRow - selection.minRow + 1;
        moveTargetLabel.textContent = `対象: 選択範囲 (${w}×${h})`;
      } else {
        moveTargetLabel.textContent = '対象: ワールド全体';
      }
    }

    // ★ 選択解除
    function clearSelection(showToastMessage = true) {
      selection = null;
      selectionRect = null;
      isDraggingSelection = false;
      updateMoveTargetLabel();
      requestRender();
      if (showToastMessage) {
        showToast('選択を解除しました');
      }
    }

    // ★ アクティブツール設定
    function setActiveTool(tool) {
      activeTool = tool;
      if (selectToolBtn) {
        if (tool === 'select') {
          selectToolBtn.classList.add('active');
          showToast('選択ツールモードになりました（ドラッグで範囲選択）');
        } else {
          selectToolBtn.classList.remove('active');
          showToast('ペイントモードになりました');
        }
      }
    }

    if (selectToolBtn) {
      selectToolBtn.addEventListener('click', () => {
        setActiveTool(activeTool === 'select' ? 'paint' : 'select');
      });
    }

    function getPaletteHeaderElement() {
      return paletteContainer?.querySelector('.palette-header') || null;
    }

    function startPaletteDrag(event) {
      if (!paletteContainer) return;
      const headerEl = getPaletteHeaderElement();
      if (!headerEl) return;
      const isButton = event.target?.closest?.('button');
      if (isButton) return;
      const rect = paletteContainer.getBoundingClientRect();
      paletteContainer.classList.add('floating');
      isDraggingPalette = true;
      paletteDragOffsetX = event.clientX - rect.left;
      paletteDragOffsetY = event.clientY - rect.top;
      event.preventDefault();
    }

    function startPaletteResize(event) {
      if (!paletteContainer) return;
      const rect = paletteContainer.getBoundingClientRect();
      paletteContainer.classList.add('floating');
      isResizingPalette = true;
      document.body.classList.add('resizing');
      paletteStartWidth = rect.width;
      paletteStartHeight = rect.height;
      paletteStartX = event.clientX;
      paletteStartY = event.clientY;
      event.preventDefault();
    }

    function movePalette(event) {
      if (!paletteContainer) return;
      if (isDraggingPalette) {
        const nextLeft = Math.max(8, Math.min(window.innerWidth - 60, event.clientX - paletteDragOffsetX));
        const nextTop = Math.max(8, Math.min(window.innerHeight - 80, event.clientY - paletteDragOffsetY));
        paletteContainer.style.left = `${nextLeft}px`;
        paletteContainer.style.top = `${nextTop}px`;
        schedulePaletteSave();
      } else if (isResizingPalette) {
        const dx = event.clientX - paletteStartX;
        const dy = event.clientY - paletteStartY;
        const nextWidth = Math.max(260, paletteStartWidth + dx);
        const nextHeight = Math.max(140, paletteStartHeight + dy);
        pendingResizeWidth = Math.min(nextWidth, window.innerWidth - 16);
        pendingResizeHeight = Math.min(nextHeight, window.innerHeight - 16);
        if (!paletteResizeFrame) {
          paletteResizeFrame = requestAnimationFrame(() => {
            paletteContainer.style.width = `${pendingResizeWidth}px`;
            paletteContainer.style.height = `${pendingResizeHeight}px`;
            paletteResizeFrame = null;
            schedulePaletteSave();
          });
        }
      }
    }

    function stopPaletteMove() {
      if (isDraggingPalette || isResizingPalette) {
        isDraggingPalette = false;
        isResizingPalette = false;
        document.body.classList.remove('resizing');
        schedulePaletteSave();
      }
    }

    function getPalettePanelState() {
      if (!paletteContainer) return null;
      const rect = paletteContainer.getBoundingClientRect();
      const floating = paletteContainer.classList.contains('floating');
      return {
        floating,
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height
      };
    }

    function applyPalettePanelState(state) {
      if (!paletteContainer || !state) return;
      if (state.floating) {
        paletteContainer.classList.add('floating');
        paletteContainer.style.left = `${Math.max(8, state.left)}px`;
        paletteContainer.style.top = `${Math.max(8, state.top)}px`;
      }
      if (state.width) {
        paletteContainer.style.width = `${Math.max(260, state.width)}px`;
      }
      if (state.height) {
        paletteContainer.style.height = `${Math.max(140, state.height)}px`;
      }
    }

    function schedulePaletteSave() {
      if (!paletteContainer) return;
      if (paletteSaveTimer) {
        clearTimeout(paletteSaveTimer);
      }
      paletteSaveTimer = setTimeout(() => {
        const state = getPalettePanelState();
        if (state) {
          writeJsonPref(PREF_PALETTE_PANEL_STATE_KEY, state);
        }
        paletteSaveTimer = null;
      }, 200);
    }

    const paletteHeader = getPaletteHeaderElement();
    if (paletteHeader) {
      paletteHeader.addEventListener('mousedown', startPaletteDrag);
    }
    if (paletteResizer) {
      paletteResizer.addEventListener('mousedown', startPaletteResize);
    }
    window.addEventListener('mousemove', movePalette);
    window.addEventListener('mouseup', stopPaletteMove);

    const savedPaletteState = readJsonPref(PREF_PALETTE_PANEL_STATE_KEY, null);
    if (savedPaletteState) {
      applyPalettePanelState(savedPaletteState);
    }

    if (clearSelectionBtn) {
      clearSelectionBtn.addEventListener('click', () => {
        clearSelection(true);
      });
    }

    // 初期表示
    updateMoveTargetLabel();

    function setSettingsModalVisible(visible) {
      if (!settingsModal) return;
      settingsModal.classList.toggle('visible', visible);
      settingsModal.setAttribute('aria-hidden', visible ? 'false' : 'true');
      if (visible && useLocalAutosaveOnLoadCheckbox) {
        useLocalAutosaveOnLoadCheckbox.focus();
      }
    }

    function setSaveHelpModalVisible(visible) {
      if (!saveHelpModal) return;
      saveHelpModal.classList.toggle('visible', visible);
      saveHelpModal.setAttribute('aria-hidden', visible ? 'false' : 'true');
      if (visible && saveHelpCloseBtn) {
        saveHelpCloseBtn.focus();
      }
    }

    if (useLocalAutosaveOnLoadCheckbox) {
      useLocalAutosaveOnLoadCheckbox.checked = readBooleanPref(PREF_USE_LOCAL_AUTOSAVE_ON_LOAD_KEY, true);
      useLocalAutosaveOnLoadCheckbox.addEventListener('change', () => {
        writeBooleanPref(PREF_USE_LOCAL_AUTOSAVE_ON_LOAD_KEY, useLocalAutosaveOnLoadCheckbox.checked);
        showToast(useLocalAutosaveOnLoadCheckbox.checked ? '起動時にローカル保存を読み込みます' : '起動時にローカル保存を読み込みません');
      });
    }

    if (settingsBtn) {
      settingsBtn.addEventListener('click', () => setSettingsModalVisible(true));
    }
    if (settingsCloseBtn) {
      settingsCloseBtn.addEventListener('click', () => setSettingsModalVisible(false));
    }
    if (settingsModal) {
      settingsModal.addEventListener('click', (event) => {
        if (event.target === settingsModal) {
          setSettingsModalVisible(false);
        }
      });
    }
    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        setSettingsModalVisible(false);
        setSaveHelpModalVisible(false);
      }
    });

    function closeSaveHelpModal() {
      if (saveHelpDontShow && saveHelpDontShow.checked) {
        writeBooleanPref(PREF_SHOW_SAVE_HELP_KEY, false);
      }
      setSaveHelpModalVisible(false);
    }

    if (saveHelpCloseBtn) {
      saveHelpCloseBtn.addEventListener('click', closeSaveHelpModal);
    }
    if (saveHelpModal) {
      saveHelpModal.addEventListener('click', (event) => {
        if (event.target === saveHelpModal) {
          closeSaveHelpModal();
        }
      });
    }

    if (clearLocalBtn) {
      clearLocalBtn.addEventListener('click', () => {
        try {
          if (supportsLocalAutosave) {
            window.localStorage.removeItem(AUTOSAVE_STORAGE_KEY);
            showToast('ローカル自動保存データを消去しました');
          } else {
            showToast('この環境ではローカル保存が無効です');
          }
        } catch (_) {}
      });
    }

    if (saveLocalBtn) {
      saveLocalBtn.addEventListener('click', () => {
        try {
          persistLocalSnapshot();
          showToast('ローカル保存しました');
        } catch (error) {
          console.error('ローカル保存に失敗しました', error);
          showToast('ローカル保存に失敗しました');
        }
      });
    }

    if (resetCameraBtn) {
      resetCameraBtn.addEventListener('click', () => {
        const clamped = clampCamera(DEFAULT_CAMERA_X, DEFAULT_CAMERA_Y);
        camera.x = clamped.x;
        camera.y = clamped.y;
        requestRender();
        scheduleCameraSave();
        showToast('カメラ位置をリセットしました');
      });
    }
    
    const headerElement = document.querySelector('header');

    const assetMapRef = assetMap || {};
    const initialTerrainMap = initialMapData || null;
    const AUTOSAVE_ENDPOINT = 'http://localhost:5173/save-terrain';
    const AUTOSAVE_DELAY_MS = 1200;
    const AUTOSAVE_SUCCESS_TOAST_INTERVAL_MS = 15000;
    const supportsLocalAutosave = typeof window !== 'undefined' && !!window.localStorage;
    let autosaveTimerId = null;
    let autosaveInFlight = false;
    let autosaveSuppressCount = 0;
    let lastAutosaveSuccessToast = 0;
    let autosaveVersion = 0;
    let autosaveSavedVersion = 0;
    const TRANSPARENT_PIXEL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==';
    const INLINE_ASSET_NAMES = [
      'grass.png',
      'dirt.png',
      'grass-dirt.png',
      'dirt2.png',
      'dirt3.png',
      'dirt4.png',
      'grass-dirt2.png',
      'grass-dirt3.png',
      'dirt2_fh.png',
      'dirt_fh.png',
      'grass-dirt_fh.png',
      'grass_fh.png',
      'dirt3_fh.png',
      'stone1.png',
      'stone2.png',
      'stone-dirt.png',
      'stone-dirt_fh.png',
      'stone-grass.png',
      'stone-grass_fh.png',
      'stone-grass2_fh.png',
      'stone-grass2.png',
      'log1.png',
      'log2.png',
      'leaf1.png',
      'leaf2.png',
      'leaf3.png',
      'leaf4.png',
      'leaf5.png',
      'leaf6.png',
      'leaf5_fh.png',
      'leaf6_fh.png',
      'dirt_back.png',
      'stone-dirt_back.png',
      'stone-dirt_fh_back.png',
      'stone1_back.png',
      'poison1.png',
      'poison2.png',
      'poison3.png',
      'sand.png',
      'sand-grass.png',
      'sand-grass_fh.png',
      'sand-dirt.png',
      'sand-dirt_fh.png',
      'sand-stone.png',
      'sand-stone_fh.png',
      'sand-stone2.png',
      'sand-stone2_fh.png',
      'ladder.png',
      'treasure_chest.png',
      'rock1.png',
      'rock2.png',
      'rock3.png',
      'rock2_fh.png'
    ];
    const DEFAULT_INLINE_ASSETS = Object.freeze(
      Object.fromEntries(INLINE_ASSET_NAMES.map((name) => [name, TRANSPARENT_PIXEL]))
    );

    const HORIZONTAL_FLIP_REMAP = new Map([
      [1, 10],
      [10, 1],
      [2, 8],
      [8, 2],
      [3, 9],
      [9, 3],
      [4, 7],
      [7, 4],
      [5, 11],
      [11, 5]
    ]);

    function resolveAsset(name, fallbackPath) {
      if (assetMapRef && assetMapRef[name]) {
        return assetMapRef[name];
      }
      if (fallbackPath) {
        return fallbackPath;
      }
      if (DEFAULT_INLINE_ASSETS[name]) {
        return DEFAULT_INLINE_ASSETS[name];
      }
      return TRANSPARENT_PIXEL;
    }

        const basePaletteItems = [
      { id: 0, name: 'air', assetName: null, src: null },
      { id: 1, name: 'grass', assetName: 'grass.png', src: resolveAsset('grass.png', 'assets/grass.png') },
      { id: 2, name: 'dirt', assetName: 'dirt.png', src: resolveAsset('dirt.png', 'assets/dirt.png') },
      { id: 3, name: 'grass-dirt', assetName: 'grass-dirt.png', src: resolveAsset('grass-dirt.png', 'assets/grass-dirt.png') },
      { id: 4, name: 'dirt2', assetName: 'dirt2.png', src: resolveAsset('dirt2.png', 'assets/dirt2.png') },
      { id: 5, name: 'dirt3', assetName: 'dirt3.png', src: resolveAsset('dirt3.png', 'assets/dirt3.png') },
      { id: 6, name: 'dirt4', assetName: 'dirt4.png', src: resolveAsset('dirt4.png', 'assets/dirt4.png') },
      { id: 7, name: 'dirt2_fh', assetName: 'dirt2_fh.png', src: resolveAsset('dirt2_fh.png', 'assets/dirt2_fh.png') },
      { id: 8, name: 'dirt_fh', assetName: 'dirt_fh.png', src: resolveAsset('dirt_fh.png', 'assets/dirt_fh.png') },
      { id: 9, name: 'grass-dirt_fh', assetName: 'grass-dirt_fh.png', src: resolveAsset('grass-dirt_fh.png', 'assets/grass-dirt_fh.png') },
      { id: 10, name: 'grass_fh', assetName: 'grass_fh.png', src: resolveAsset('grass_fh.png', 'assets/grass_fh.png') },
      { id: 11, name: 'dirt3_fh', assetName: 'dirt3_fh.png', src: resolveAsset('dirt3_fh.png', 'assets/dirt3_fh.png') },
      { id: 12, name: 'stone1', assetName: 'stone1.png', src: resolveAsset('stone1.png', 'assets/stone1.png') },
      { id: 13, name: 'stone2', assetName: 'stone2.png', src: resolveAsset('stone2.png', 'assets/stone2.png') },
      { id: 14, name: 'stone-dirt', assetName: 'stone-dirt.png', src: resolveAsset('stone-dirt.png', 'assets/stone-dirt.png') },
      { id: 15, name: 'stone-dirt_fh', assetName: 'stone-dirt_fh.png', src: resolveAsset('stone-dirt_fh.png', 'assets/stone-dirt_fh.png') },
      { id: 16, name: 'stone-grass', assetName: 'stone-grass.png', src: resolveAsset('stone-grass.png', 'assets/stone-grass.png') },
      { id: 17, name: 'stone-grass_fh', assetName: 'stone-grass_fh.png', src: resolveAsset('stone-grass_fh.png', 'assets/stone-grass_fh.png') },
      { id: 18, name: 'stone-grass2', assetName: 'stone-grass2.png', src: resolveAsset('stone-grass2.png', 'assets/stone-grass2.png') },
      { id: 19, name: 'stone-grass2_fh', assetName: 'stone-grass2_fh.png', src: resolveAsset('stone-grass2_fh.png', 'assets/stone-grass2_fh.png') },
      { id: 20, name: 'log1', assetName: 'log1.png', src: resolveAsset('log1.png', 'assets/log1.png') },
      { id: 21, name: 'log2', assetName: 'log2.png', src: resolveAsset('log2.png', 'assets/log2.png') },
      { id: 22, name: 'leaf1', assetName: 'leaf1.png', src: resolveAsset('leaf1.png', 'assets/leaf1.png') },
      { id: 23, name: 'leaf2', assetName: 'leaf2.png', src: resolveAsset('leaf2.png', 'assets/leaf2.png') },
      { id: 24, name: 'leaf3', assetName: 'leaf3.png', src: resolveAsset('leaf3.png', 'assets/leaf3.png') },
      { id: 25, name: 'leaf4', assetName: 'leaf4.png', src: resolveAsset('leaf4.png', 'assets/leaf4.png') },
      { id: 26, name: 'leaf5', assetName: 'leaf5.png', src: resolveAsset('leaf5.png', 'assets/leaf5.png') },
      { id: 27, name: 'leaf6', assetName: 'leaf6.png', src: resolveAsset('leaf6.png', 'assets/leaf6.png') },
      { id: 28, name: 'leaf5_fh', assetName: 'leaf5_fh.png', src: resolveAsset('leaf5_fh.png', 'assets/leaf5_fh.png') },
      { id: 29, name: 'leaf6_fh', assetName: 'leaf6_fh.png', src: resolveAsset('leaf6_fh.png', 'assets/leaf6_fh.png') },
      { id: 30, name: 'dirt_back', assetName: 'dirt_back.png', src: resolveAsset('dirt_back.png', 'assets/dirt_back.png') },
      { id: 31, name: 'stone-dirt_back', assetName: 'stone-dirt_back.png', src: resolveAsset('stone-dirt_back.png', 'assets/stone-dirt_back.png') },
      { id: 32, name: 'stone-dirt_fh_back', assetName: 'stone-dirt_fh_back.png', src: resolveAsset('stone-dirt_fh_back.png', 'assets/stone-dirt_fh_back.png') },
      { id: 33, name: 'stone1_back', assetName: 'stone1_back.png', src: resolveAsset('stone1_back.png', 'assets/stone1_back.png') },
       { id: 34, name: 'poison', assetName: "poison1.png",src: resolveAsset("poison1.png", 'assets/poison1.png') },
      { id: 35, name: 'sand', assetName: 'sand.png', src: resolveAsset('sand.png', 'assets/sand.png') },
      { id: 36, name: 'sand-grass', assetName: 'sand-grass.png', src: resolveAsset('sand-grass.png', 'assets/sand-grass.png') },
      { id: 37, name: 'sand-grass_fh', assetName: 'sand-grass_fh.png', src: resolveAsset('sand-grass_fh.png', 'assets/sand-grass_fh.png') },
      { id: 38, name: 'sand-dirt', assetName: 'sand-dirt.png', src: resolveAsset('sand-dirt.png', 'assets/sand-dirt.png') },
      { id: 39, name: 'sand-dirt_fh', assetName: 'sand-dirt_fh.png', src: resolveAsset('sand-dirt_fh.png', 'assets/sand-dirt_fh.png') },
      { id: 40, name: 'sand-stone', assetName: 'sand-stone.png', src: resolveAsset('sand-stone.png', 'assets/sand-stone.png') },
      { id: 41, name: 'sand-stone_fh', assetName: 'sand-stone_fh.png', src: resolveAsset('sand-stone_fh.png', 'assets/sand-stone_fh.png') },
      { id: 42, name: 'sand-stone2', assetName: 'sand-stone2.png', src: resolveAsset('sand-stone2.png', 'assets/sand-stone2.png') },
      { id: 43, name: 'sand-stone2_fh', assetName: 'sand-stone2_fh.png', src: resolveAsset('sand-stone2_fh.png', 'assets/sand-stone2_fh.png') },
      { id: 44, name: 'ladder', assetName: 'ladder.png', src: resolveAsset('ladder.png', 'assets/ladder.png') },
      { id: 45, name: 'water', assetName: 'water.png', src: resolveAsset('water.png', 'assets/water.png') },
      { id: 46, name: 'water2', assetName: 'water2.png', src: resolveAsset('water2.png', 'assets/water2.png') },
      { id: 47, name: 'treasure_chest', assetName: 'treasure_chest.png', src: resolveAsset('treasure_chest.png', 'assets/treasure_chest.png') },
      { id: 48, name: 'rock1', assetName: 'rock1.png', src: resolveAsset('rock1.png', 'assets/rock1.png') },
      { id: 49, name: 'rock2', assetName: 'rock2.png', src: resolveAsset('rock2.png', 'assets/rock2.png') },
      { id: 50, name: 'rock3', assetName: 'rock3.png', src: resolveAsset('rock3.png', 'assets/rock3.png') },
      { id: 51, name: 'rock2_fh', assetName: 'rock2_fh.png', src: resolveAsset('rock2_fh.png', 'assets/rock2_fh.png') },
      { id: 52, name: 'treasure_chest2', assetName: 'treasure_chest2.png', src: resolveAsset('treasure_chest2.png', 'assets/treasure_chest2.png') },
      { id: 53, name: 'treasure_chest3', assetName: 'treasure_chest3.png', src: resolveAsset('treasure_chest3.png', 'assets/treasure_chest3.png') },
      { id: 54, name: 'trampoline_mushroom', assetName: 'trampoline_mushroom.png', src: resolveAsset('trampoline_mushroom.png', 'assets/trampoline_mushroom.png') },
      { id: 55, name: 'treasure_chest4', assetName: 'treasure_chest4.png', src: resolveAsset('treasure_chest4.png', 'assets/treasure_chest4.png') },
      { id: 56, name: 'treasure_chest5', assetName: 'treasure_chest5.png', src: resolveAsset('treasure_chest5.png', 'assets/treasure_chest5.png') },
      { id: 57, name: 'treasure_chest6', assetName: 'treasure_chest6.png', src: resolveAsset('treasure_chest6.png', 'assets/treasure_chest6.png') },
      { id: 58, name: 'slime', assetName : 'idle1.png', src: resolveAsset('idle1.png','assets/slime/feel/idle1.png') },
      { id: 59, name: 'sand-log1', assetName: 'sand-log1.png', src: resolveAsset('sand-log1.png', 'assets/sand-log1.png') },
      { id: 60, name: 'sand-leaf1', assetName: 'sand-leaf1.png', src: resolveAsset('sand-leaf1.png', 'assets/sand-leaf1.png') },
      { id: 61, name: 'sand-leaf2', assetName: 'sand-log2.png', src: resolveAsset('sand-log2.png', 'assets/sand-log2.png') },
      { id: 62, name: 'sand-leaf3', assetName: 'sand-leaf3.png', src: resolveAsset('sand-leaf3.png', 'assets/sand-leaf3.png') },
      { id: 63, name: 'sand-leaf4', assetName: 'sand-leaf4.png', src: resolveAsset('sand-leaf4.png', 'assets/sand-leaf4.png') },
      { id: 64, name: 'sand-leaf5', assetName: 'sand-leaf5.png', src: resolveAsset('sand-leaf5.png', 'assets/sand-leaf5.png') },
      { id: 65, name: 'sand-leaf6', assetName: 'sand-leaf6.png', src: resolveAsset('sand-leaf6.png', 'assets/sand-leaf6.png') },
      { id: 66, name: 'sand-leaf5_fh', assetName: 'sand-leaf5_fh.png', src: resolveAsset('sand-leaf5_fh.png', 'assets/sand-leaf5_fh.png') },
      { id: 67, name: 'sand-leaf6_fh', assetName: 'sand-leaf6_fh.png', src: resolveAsset('sand-leaf6_fh.png', 'assets/sand-leaf6_fh.png') },
      { id: 68, name: 'stone-break1', assetName: 'stone-break1.png', src: resolveAsset('stone-break1.png', 'assets/stone-break1.png') },
      { id: 69, name: 'stone-break2', assetName: 'stone-break2.png', src: resolveAsset('stone-break2.png', 'assets/stone-break2.png') },
      { id: 70, name: 'stone-break3', assetName: 'stone-break3.png', src: resolveAsset('stone-break3.png', 'assets/stone-break3.png') },
      { id: 71, name: 'snake', assetName : 'idle1.png', src: resolveAsset('idle1.png','assets/snake/idle1.png') },
      { id: 72, name: 'leaf_block', assetName : 'leaf1.png', src: resolveAsset('leaf1.png','assets/leaf1.png') },
      { id: 73, name: 'leaf_block1', assetName : 'leaf_block1.png', src: resolveAsset('leaf_block1.png','assets/leaf_block1.png') },
      { id: 74, name: 'leaf_block2', assetName : 'leaf_block2.png', src: resolveAsset('leaf_block2.png','assets/leaf_block2.png') },
      { id: 75, name: 'small_stone', assetName : 'small_stone.png', src: resolveAsset('small_stone.png','assets/small_stone.png') },
      { id: 76, name: 'bushes', assetName : 'bushes.png', src: resolveAsset('bushes.png','assets/bushes.png') },
      { id: 77, name: 'moss', assetName : 'moss.png', src: resolveAsset('moss.png','assets/moss.png') },
      { id: 78, name: 'grass-leaf', assetName : 'grass-leaf.png', src: resolveAsset('grass-leaf.png','assets/grass-leaf.png') },
      { id: 79, name: 'limestone-cave_fh', assetName : 'limestone-cave_fh.png', src: resolveAsset('limestone-cave_fh.png','assets/limestone-cave_fh.png') },
      { id: 80, name: 'limestone-cave', assetName : 'limestone-cave.png', src: resolveAsset('limestone-cave.png','assets/limestone-cave.png') },
      { id: 81, name: 'paralysis_slime', assetName : 'idle1.png', src: resolveAsset('idle1.png','assets/paralysis_slime/idle1.png') },
      { id: 82, name: 'giant_slime', assetName : 'idle1.png', src: resolveAsset('idle1.png','assets/slime/giant_slime_lv1/idle1.png') },
      { id: 83, name: 'dark-grass', assetName : 'dark-grass.png', src: resolveAsset('dark-grass.png','assets/dark-grass.png') },
      { id: 150, name: 'great_serpent_head', assetName : 'great_snake/head.png', src: resolveAsset('great_snake/head.png','assets/great_snake/head.png') },
      { id: 151, name: 'great_serpent_body', assetName : 'great_snake/body.png', src: resolveAsset('great_snake/body.png','assets/great_snake/body.png') },
      { id: 152, name: 'great_serpent_tail', assetName : 'great_snake/tail.png', src: resolveAsset('great_snake/tail.png','assets/great_snake/tail.png') },
      { id: 84, name: 'dark-dirt', assetName : 'dark-dirt.png', src: resolveAsset('dark-dirt.png','assets/dark-dirt.png') },
      { id: 85, name: 'dark-leaf1', assetName : 'dark-leaf1.png',src: resolveAsset('dark-leaf1.png','assets/dark-leaf1.png') },
      { id: 86, name: 'dark-leaf2', assetName : 'dark-leaf2.png',src: resolveAsset('dark-leaf2.png','assets/dark-leaf2.png') },
      { id: 87, name: 'dark-leaf3', assetName : 'dark-leaf3.png',src: resolveAsset('dark-leaf3.png','assets/dark-leaf3.png') },
      { id: 89, name: 'cloud', assetName : 'cloud.png',src: resolveAsset('cloud.png','assets/cloud.png') },
      { id: 90, name: 'cloud1', assetName : 'cloud2.png',src: resolveAsset('cloud2.png','assets/cloud2.png') },
      { id: 91, name: 'cloud2', assetName : 'cloud3.png',src: resolveAsset('cloud3.png','assets/cloud3.png') },
  ];

  const DEBUG_ZOOM_BASE = 10000;
  const ZOOM_MIN = 0.1;
  const ZOOM_MAX = 10;
  const ZOOM_STEP = 0.1;
  const zoomPaletteItems = [{ id: 0, name: '削除', assetName: null, src: null }];
  for (let value = ZOOM_MIN; value <= ZOOM_MAX + 0.0001; value += ZOOM_STEP) {
    const normalized = Math.round(value * 100);
    const tileId = DEBUG_ZOOM_BASE + normalized;
    const zoomLabel = Number(value.toFixed(1));
    zoomPaletteItems.push({
      id: tileId,
      name: `camera ${zoomLabel.toFixed(1)}`,
      assetName: null,
      src: null
    });
  }

  const BACKGROUND_ENTER_BASE = 20000;
  const BACKGROUND_DEFINITIONS = [
    { id: 1, label: '森丘', image: 'assets/forest1.png', colors: ['#243c26', '#6ca741'], opacity: 0.75, tintEnabled: false },
    { id: 2, label: '山岳', image: 'assets/limestone-cave.png', colors: ['#1b2233', '#6f7d8c'], opacity: 0.75, tintEnabled: false },
    { id: 3, label: '沼地', image: 'assets/moss.png', colors: ['#12230c', '#3c5d34'], opacity: 0.72, tintEnabled: false },
    { id: 4, label: '森', image: 'assets/leaf_block1.png', colors: ['#0c1508', '#1f3a12'], opacity: 0.78, tintEnabled: false },
    { id: 5, label: '温帯', image: 'assets/grass.png', colors: ['#1a3310', '#78b047'], opacity: 0.75, tintEnabled: false },
    { id: 6, label: '砂漠', image: 'assets/sand.png', colors: ['#5f3a18', '#d6aa62'], opacity: 0.7, tintEnabled: false },
    { id: 7, label: '海', image: 'assets/water.png', colors: ['#041627', '#0c4f7c'], opacity: 0.72, tintEnabled: false },
    { id: 8, label: '密林', image: 'assets/forest1.png', colors: ['#07150a', '#2c4f2a'], opacity: 0.78, tintEnabled: false },
  ];
  const backgroundPaletteItems = [{ id: 0, name: '削除', assetName: null, src: null }];
  BACKGROUND_DEFINITIONS.forEach((def) => {
    backgroundPaletteItems.push({
      id: BACKGROUND_ENTER_BASE + def.id,
      name: `[背景] ${def.label}`,
      assetName: null,
      src: null
    });
  });
    
    const assetNames = Object.keys(assetMapRef).filter((name) => /\.png$/i.test(name));
    const knownAssetNames = new Set(basePaletteItems.filter((item) => item.assetName).map((item) => item.assetName));
    let nextPaletteId = basePaletteItems.reduce((max, item) => Math.max(max, item.id), 0) + 1;
    const extraPaletteItems = [];
    assetNames.sort().forEach((name) => {
      if (knownAssetNames.has(name)) {
        return;
      }
      extraPaletteItems.push({
        id: nextPaletteId++,
        name: name.replace(/\.[^.]+$/, ''),
        assetName: name,
        src: resolveAsset(name, `assets/${name}`)
      });
    });

    const DEBUG_TILE_IDS = {
      HELP_MOVE: 9001,
      HELP_JUMP: 9002,
      HELP_SQUAT: 9003,
      HELP_DROP: 9004,
      PLAYER_SPAWN: 9010,
      DEATH_LINE: 9011
    };

    const HELP_TILE_MESSAGES = {
      [DEBUG_TILE_IDS.HELP_MOVE]: '移動',
      [DEBUG_TILE_IDS.HELP_JUMP]: 'ジャンプ',
      [DEBUG_TILE_IDS.HELP_SQUAT]: 'しゃがむ',
      [DEBUG_TILE_IDS.HELP_DROP]: 'ドロップ',
      [DEBUG_TILE_IDS.HELP_INVENTORY]: 'インベントリ',
    };

    const helpPaletteItems = [
      { id: 0, name: '削除', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.HELP_MOVE, name: 'help1 移動', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.HELP_JUMP, name: 'help2 ジャンプ', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.HELP_SQUAT, name: 'help3 しゃがむ', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.HELP_DROP, name: 'help4 ドロップ', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.HELP_INVENTORY, name: 'help5 インベントリ', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.PLAYER_SPAWN, name: 'スポーン地点', assetName: null, src: null },
      { id: DEBUG_TILE_IDS.DEATH_LINE, name: '落下デスライン', assetName: null, src: null }
    ];

    const paletteCategories = [
      { key: 'basic', label: '基本', items: basePaletteItems },
      { key: 'all', label: '全画像', items: basePaletteItems.concat(extraPaletteItems) },
      { key: 'zoom', label: 'カメラ', items: zoomPaletteItems },
      { key: 'background', label: '背景', items: backgroundPaletteItems },
      { key: 'help', label: 'ヘルプ', items: helpPaletteItems }
    ];

    const allPaletteItems = basePaletteItems
      .concat(extraPaletteItems, zoomPaletteItems, backgroundPaletteItems, helpPaletteItems);
    const paletteItemById = new Map(allPaletteItems.map((item) => [item.id, item]));
    const tileImages = {};
    const validTileIds = new Set(allPaletteItems.map((item) => item.id));

    function getTileImageById(tileId) {
      if (tileImages[tileId]) {
        return tileImages[tileId];
      }
      const item = paletteItemById.get(tileId);
      if (!item || !item.src) {
        return null;
      }
      const img = new Image();
      img.onerror = () => {
        img.onerror = null;
        img.src = TRANSPARENT_PIXEL;
      };
      img.src = item.src;
      tileImages[tileId] = img;
      return img;
    }

    (function preloadPoisonFrames() {
      const frameNames = ['poison1.png', 'poison2.png', 'poison3.png'];
      frameNames.forEach((name) => {
        const src = resolveAsset(name, `assets/${name}`);
        if (!src) {
          return;
        }
        const frame = new Image();
        frame.onerror = () => {
          frame.onerror = null;
          frame.src = TRANSPARENT_PIXEL;
        };
        frame.src = src;
        window.poisonImages.push(frame);
      });
    })();

    const map = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
    // レイヤー配列化: 背景/前前景ともに複数レイヤーを持てる
    const backgroundLayers = [
      {
        name: '背景 1',
        map: Array.from({ length: ROWS }, () => new Array(COLS).fill(0)),
        flipH: Array.from({ length: ROWS }, () => new Array(COLS).fill(false)),
        flipV: Array.from({ length: ROWS }, () => new Array(COLS).fill(false)),
      }
    ];
    const frontLayers = [
      {
        name: '前前景 1',
        map: Array.from({ length: ROWS }, () => new Array(COLS).fill(0)),
        flipH: Array.from({ length: ROWS }, () => new Array(COLS).fill(false)),
        flipV: Array.from({ length: ROWS }, () => new Array(COLS).fill(false)),
      }
    ];
    // 互換用（既存コードへの影響を減らすため、先頭レイヤーを既存変数へバインド）
    const backgroundMap = backgroundLayers[0].map;
    const backgroundFlipH = backgroundLayers[0].flipH;
    const backgroundFlipV = backgroundLayers[0].flipV;
    const frontMap = frontLayers[0].map;
    const frontFlipH = frontLayers[0].flipH;
    const frontFlipV = frontLayers[0].flipV;
    const debugMap = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
    const flipH = Array.from({ length: ROWS }, () => new Array(COLS).fill(false));
    const flipV = Array.from({ length: ROWS }, () => new Array(COLS).fill(false));
    const debugFlipH = Array.from({ length: ROWS }, () => new Array(COLS).fill(false));
    const debugFlipV = Array.from({ length: ROWS }, () => new Array(COLS).fill(false));
    let debugSpawnLocation = null;

    function refreshDebugSpecialMarkers() {
      debugSpawnLocation = null;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const tileId = debugMap[row][col];
          if (tileId === DEBUG_TILE_IDS.PLAYER_SPAWN) {
            if (!debugSpawnLocation) {
              debugSpawnLocation = { row, col };
            } else {
              // Enforce a single spawn marker by clearing extras
              debugMap[row][col] = 0;
            }
          }
        }
      }
    }

      const camera = {
      x: DEFAULT_CAMERA_X,
      y: DEFAULT_CAMERA_Y
    };

    const keys = {
      w: false,
      a: false,
      s: false,
      d: false,
      W: false,
      A: false,
      S: false,
      D: false,
      Shift: false,
      control: false,
      Control: false,
      Meta: false
    };

    let mouseDown = false;

    // ★ 追加: ツール & 選択状態
    let activeTool = 'paint'; // 'paint' | 'select'
    let isDraggingSelection = false;

    const selectedTileByLayer = {
      foreground: 1,
      front: 0,
      background: 0,
      debug: 9001
    };

  let activeLayer = 'foreground';
  let brushFlipH = false;
  let brushFlipV = false;
  let mapHasUnsavedChanges = false;
  let lastAutosaveResult = 'idle';
  let needsRender = true;
  const BACKGROUND_SHADOW_BRIGHTNESS = 1;
  const darkTileCache = Object.create(null);
  const flippedTileCache = Object.create(null);
  const LOCAL_AUTOSAVE_DELAY_MS = 700;
  let localAutosaveTimerId = null;
  const cachedBounds = { minRow: 0, maxRow: -1, minCol: 0, maxCol: -1, dirty: true };
  const RENDER_MAX_FPS = 60;
  let lastRenderTime = 0;
  const sparseIndexes = {
    foreground: { rows: new Map() },
    background: [],
    front: [],
    debug: { rows: new Map() }
  };

    function requestRender() {
      needsRender = true;
    }

    function getSelectedTile() {
      return selectedTileByLayer[activeLayer];
    }

    function setSelectedTile(tileId) {
      selectedTileByLayer[activeLayer] = tileId;
    }

    function createSparseIndex() {
      return { rows: new Map() };
    }

    function clearSparseIndex(index) {
      index.rows.clear();
    }

    function addSparseCell(index, row, col) {
      let rowSet = index.rows.get(row);
      if (!rowSet) {
        rowSet = new Set();
        index.rows.set(row, rowSet);
      }
      rowSet.add(col);
    }

    function removeSparseCell(index, row, col) {
      const rowSet = index.rows.get(row);
      if (!rowSet) return;
      rowSet.delete(col);
      if (rowSet.size === 0) {
        index.rows.delete(row);
      }
    }

    function rebuildSparseIndexFromMap(index, sourceMap) {
      clearSparseIndex(index);
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (sourceMap[row][col] !== 0) {
            addSparseCell(index, row, col);
          }
        }
      }
    }

    function ensureSparseIndexArrays() {
      while (sparseIndexes.background.length < backgroundLayers.length) {
        sparseIndexes.background.push(createSparseIndex());
      }
      while (sparseIndexes.front.length < frontLayers.length) {
        sparseIndexes.front.push(createSparseIndex());
      }
      if (sparseIndexes.background.length > backgroundLayers.length) {
        sparseIndexes.background.length = backgroundLayers.length;
      }
      if (sparseIndexes.front.length > frontLayers.length) {
        sparseIndexes.front.length = frontLayers.length;
      }
    }

    function rebuildAllSparseIndexes() {
      ensureSparseIndexArrays();
      rebuildSparseIndexFromMap(sparseIndexes.foreground, map);
      backgroundLayers.forEach((layer, idx) => {
        rebuildSparseIndexFromMap(sparseIndexes.background[idx], layer.map);
      });
      frontLayers.forEach((layer, idx) => {
        rebuildSparseIndexFromMap(sparseIndexes.front[idx], layer.map);
      });
      rebuildSparseIndexFromMap(sparseIndexes.debug, debugMap);
    }

    function rebuildActiveLayerSparseIndex() {
      if (activeLayer === 'background') {
        ensureSparseIndexArrays();
        const layer = backgroundLayers[activeBackgroundIndex];
        const index = sparseIndexes.background[activeBackgroundIndex];
        if (layer && index) {
          rebuildSparseIndexFromMap(index, layer.map);
        }
        return;
      }
      if (activeLayer === 'front') {
        ensureSparseIndexArrays();
        const layer = frontLayers[activeFrontIndex];
        const index = sparseIndexes.front[activeFrontIndex];
        if (layer && index) {
          rebuildSparseIndexFromMap(index, layer.map);
        }
        return;
      }
      if (activeLayer === 'debug') {
        rebuildSparseIndexFromMap(sparseIndexes.debug, debugMap);
        return;
      }
      rebuildSparseIndexFromMap(sparseIndexes.foreground, map);
    }

    function updateBoundsOnAdd(row, col) {
      if (cachedBounds.maxRow === -1) {
        cachedBounds.minRow = row;
        cachedBounds.maxRow = row;
        cachedBounds.minCol = col;
        cachedBounds.maxCol = col;
        return;
      }
      if (row < cachedBounds.minRow) cachedBounds.minRow = row;
      if (row > cachedBounds.maxRow) cachedBounds.maxRow = row;
      if (col < cachedBounds.minCol) cachedBounds.minCol = col;
      if (col > cachedBounds.maxCol) cachedBounds.maxCol = col;
    }

    function cellHasAnyTile(row, col) {
      if (map[row][col] !== 0 || debugMap[row][col] !== 0) {
        return true;
      }
      for (const layer of backgroundLayers) {
        if (layer?.map?.[row]?.[col] !== 0) {
          return true;
        }
      }
      for (const layer of frontLayers) {
        if (layer?.map?.[row]?.[col] !== 0) {
          return true;
        }
      }
      return false;
    }

    function markBoundsDirtyIfBoundary(row, col) {
      if (
        row === cachedBounds.minRow ||
        row === cachedBounds.maxRow ||
        col === cachedBounds.minCol ||
        col === cachedBounds.maxCol
      ) {
        cachedBounds.dirty = true;
      }
    }

    function recalcBounds() {
      let minRow = ROWS;
      let maxRow = -1;
      let minCol = COLS;
      let maxCol = -1;
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          if (cellHasAnyTile(row, col)) {
            if (row < minRow) minRow = row;
            if (row > maxRow) maxRow = row;
            if (col < minCol) minCol = col;
            if (col > maxCol) maxCol = col;
          }
        }
      }
      if (maxRow === -1) {
        cachedBounds.minRow = 0;
        cachedBounds.maxRow = -1;
        cachedBounds.minCol = 0;
        cachedBounds.maxCol = -1;
      } else {
        cachedBounds.minRow = minRow;
        cachedBounds.maxRow = maxRow;
        cachedBounds.minCol = minCol;
        cachedBounds.maxCol = maxCol;
      }
      cachedBounds.dirty = false;
    }

    function clampCamera(x, y) {
      const viewWidth = canvas.width / RENDER_SCALE;
      const viewHeight = canvas.height / RENDER_SCALE;
      const clampedX = Math.max(0, Math.min(x, COLS * TILE_SIZE - viewWidth));
      const clampedY = Math.max(0, Math.min(y, ROWS * TILE_SIZE - viewHeight));
      return { x: clampedX, y: clampedY };
    }

    function resizeCanvas() {
      canvas.width = Math.max(320, Math.floor(window.innerWidth * RENDER_SCALE));
      const headerHeight = headerElement?.offsetHeight ?? 64;
      canvas.height = Math.max(320, Math.floor((window.innerHeight - headerHeight - 16) * RENDER_SCALE));
      const clamped = clampCamera(camera.x, camera.y);
      camera.x = clamped.x;
      camera.y = clamped.y;
      requestRender();
    }
    resizeCanvas();
    
    window.addEventListener('resize', resizeCanvas);

    function scheduleCameraSave() {
      if (scheduleCameraSave.timerId) {
        clearTimeout(scheduleCameraSave.timerId);
      }
      scheduleCameraSave.timerId = setTimeout(() => {
        writeJsonPref(PREF_CAMERA_STATE_KEY, { x: camera.x, y: camera.y });
        scheduleCameraSave.timerId = null;
      }, 200);
    }
    scheduleCameraSave.timerId = null;

    function applySavedCamera() {
      const saved = readJsonPref(PREF_CAMERA_STATE_KEY, null);
      if (!saved || !Number.isFinite(saved.x) || !Number.isFinite(saved.y)) {
        return;
      }
      const clamped = clampCamera(saved.x, saved.y);
      camera.x = clamped.x;
      camera.y = clamped.y;
      requestRender();
    }

    function isAutosaveAvailable() {
      return !!AUTOSAVE_ENDPOINT;
    }

    function markDirty() {
      autosaveVersion += 1;
      mapHasUnsavedChanges = true;
      requestRender();
      if (!isAutosaveAvailable()) {
        scheduleLocalAutosave();
        return;
      }
      if (autosaveSuppressCount > 0) {
        return;
      }
      scheduleAutosave();
    }

    function saveAutosavePayload(payload) {
      if (!supportsLocalAutosave) {
        return;
      }
      try {
        window.localStorage.setItem(AUTOSAVE_STORAGE_KEY, JSON.stringify(payload));
      } catch (error) {
        console.warn('ローカル自動保存データの保存に失敗しました', error);
      }
    }

    function persistLocalSnapshot() {
      if (!supportsLocalAutosave) {
        return;
      }
      try {
        const payload = exportMapData();
        saveAutosavePayload(payload);
        mapHasUnsavedChanges = false;
      } catch (error) {
        console.warn('ローカル自動保存データの作成に失敗しました', error);
      }
    }

    function scheduleLocalAutosave() {
      if (!supportsLocalAutosave) return;
      if (localAutosaveTimerId) {
        clearTimeout(localAutosaveTimerId);
      }
      localAutosaveTimerId = setTimeout(() => {
        persistLocalSnapshot();
        localAutosaveTimerId = null;
      }, LOCAL_AUTOSAVE_DELAY_MS);
    }

    function scheduleAutosave() {
      if (autosaveTimerId) {
        clearTimeout(autosaveTimerId);
      }
      autosaveTimerId = setTimeout(runAutosave, AUTOSAVE_DELAY_MS);
    }

    async function runAutosave() {
      if (!isAutosaveAvailable()) {
        persistLocalSnapshot();
        autosaveTimerId = null;
        autosaveInFlight = false;
        return;
      }
      if (autosaveSuppressCount > 0) {
        autosaveTimerId = null;
        return;
      }
      if (autosaveVersion === autosaveSavedVersion) {
        mapHasUnsavedChanges = false;
        autosaveTimerId = null;
        return;
      }
      if (autosaveInFlight) {
        autosaveTimerId = setTimeout(runAutosave, AUTOSAVE_DELAY_MS);
        return;
      }

      autosaveTimerId = null;
      autosaveInFlight = true;
      const targetVersion = autosaveVersion;
      const payload = exportMapData();

      try {
        const response = await fetch(AUTOSAVE_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        saveAutosavePayload(payload);
        autosaveInFlight = false;
        autosaveSavedVersion = targetVersion;
        lastAutosaveResult = 'success';
        if (autosaveSavedVersion === autosaveVersion) {
          mapHasUnsavedChanges = false;
          const now = Date.now();
          if (now - lastAutosaveSuccessToast > AUTOSAVE_SUCCESS_TOAST_INTERVAL_MS) {
            showToast('terrain-data.jsを自動保存しました');
            lastAutosaveSuccessToast = now;
          }
        } else {
          mapHasUnsavedChanges = true;
          scheduleAutosave();
        }
      } catch (error) {
        autosaveInFlight = false;
        lastAutosaveResult = 'error';
        console.error('terrain-data.js の自動保存に失敗しました', error);
        showToast('terrain-data.jsの保存に失敗しました');
        scheduleAutosave();
      }
    }

    const layerTabsElement = document.getElementById('layerTabs');
    const paletteTabsElement = document.getElementById('paletteTabs');
    const fixedLayers = [
      { key: 'foreground', label: '前景' },
      { key: 'debug', label: 'デバッグ' }
    ];
    let activePaletteKey = 'basic';
    let activeBackgroundIndex = 0;
    let activeFrontIndex = 0;

    function renderLayerTabs(options) {
      const silent = options?.silent ?? false;
      if (!layerTabsElement) {
        return;
      }
      layerTabsElement.innerHTML = '';
      const dynamicBackgroundTabs = backgroundLayers.map((layer, idx) => ({
        key: `background_${idx}`,
        label: layer.name || `背景 ${idx + 1}`,
        type: 'background',
        index: idx
      }));
      const dynamicFrontTabs = frontLayers.map((layer, idx) => ({
        key: `front_${idx}`,
        label: layer.name || `前前景 ${idx + 1}`,
        type: 'front',
        index: idx
      }));
      const renderTabButton = (layer) => {
        const tabButton = document.createElement('button');
        tabButton.textContent = layer.label;
        const isActive =
          layer.key === activeLayer ||
          (layer.type === 'background' && activeLayer === 'background' && activeBackgroundIndex === layer.index) ||
          (layer.type === 'front' && activeLayer === 'front' && activeFrontIndex === layer.index);
        if (isActive) {
          tabButton.classList.add('active');
        }
        tabButton.addEventListener('click', () => {
          if (layer.type === 'background') {
            activeLayer = 'background';
            activeBackgroundIndex = layer.index;
          } else if (layer.type === 'front') {
            activeLayer = 'front';
            activeFrontIndex = layer.index;
          } else {
            activeLayer = layer.key;
          }
          if (layer.key === 'debug') {
            activePaletteKey = 'help';
          } else if (activePaletteKey === 'help') {
            activePaletteKey = 'basic';
          }
          renderLayerTabs();
          renderPaletteTabs();
          buildPalette(getActivePaletteItems());
          if (!silent) {
            showToast(`${layer.label}レイヤーを編集中`);
          }
        });
        layerTabsElement.appendChild(tabButton);
      };

      dynamicBackgroundTabs.forEach(renderTabButton);

      dynamicFrontTabs.forEach(renderTabButton);

      fixedLayers.forEach(renderTabButton);

      requestRender();
    }

    function getActivePaletteItems() {
      const category = paletteCategories.find((cat) => cat.key === activePaletteKey);
      return category ? category.items : paletteCategories[0].items;
    }

    function buildPalette(items) {
      paletteElement.innerHTML = '';
      items.forEach((item) => {
        const button = document.createElement('button');
        button.dataset.tile = item.id;
        if (item.src) {
          const img = document.createElement('img');
          img.src = item.src;
          img.alt = item.name;
          img.onerror = () => {
            img.onerror = null;
            img.src = TRANSPARENT_PIXEL;
          };
          button.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.textContent = '空';
          placeholder.style.fontWeight = '600';
          button.appendChild(placeholder);
        }
        const label = document.createElement('span');
        label.textContent = `${item.id}: ${item.name}`;
        button.appendChild(label);
        if (item.id === getSelectedTile()) {
          button.classList.add('active');
        }
        button.addEventListener('click', () => {
          setSelectedTile(item.id);
          buildPalette(getActivePaletteItems());
        });
        paletteElement.appendChild(button);
      });
    }

    function renderPaletteTabs() {
      if (!paletteTabsElement) {
        return;
      }
      paletteTabsElement.innerHTML = '';
      paletteCategories.forEach((category) => {
        const tabButton = document.createElement('button');
        tabButton.textContent = category.label;
        if (category.key === activePaletteKey) {
          tabButton.classList.add('active');
        }
        tabButton.addEventListener('click', () => {
          if (activePaletteKey === category.key) {
            return;
          }
          activePaletteKey = category.key;
          renderPaletteTabs();
          buildPalette(getActivePaletteItems());
        });
        paletteTabsElement.appendChild(tabButton);
      });
    }

    renderLayerTabs({ silent: true });
    renderPaletteTabs();
    buildPalette(getActivePaletteItems());

    function showToast(message) {
      toastElement.textContent = message;
      toastElement.classList.add('visible');
      clearTimeout(showToast.timeoutId);
      showToast.timeoutId = setTimeout(() => {
        toastElement.classList.remove('visible');
      }, 2200);
    }
    showToast.timeoutId = null;

    function updateCamera() {
      const speed = keys.Shift ? CAMERA_SPEED_FAST : CAMERA_SPEED;
      let dx = 0;
      let dy = 0;
      if (keys.w || keys.W) dy -= speed;
      if (keys.s || keys.S) dy += speed;
      if (keys.a || keys.A) dx -= speed;
      if (keys.d || keys.D) dx += speed;

      const prevX = camera.x;
      const prevY = camera.y;
      const next = clampCamera(prevX + dx, prevY + dy);
      const nextX = next.x;
      const nextY = next.y;
      if (nextX !== prevX || nextY !== prevY) {
        camera.x = nextX;
        camera.y = nextY;
        requestRender();
        scheduleCameraSave();
        return true;
      }
      return false;
    }

    function worldToTile(x, y) {
      const col = Math.floor((x + camera.x) / TILE_SIZE);
      const row = Math.floor((y + camera.y) / TILE_SIZE);
      return { col, row };
    }

    function setTileAt(col, row, tileId) {
      if (col < 0 || col >= COLS || row < 0 || row >= ROWS) {
        return;
      }
      if (tileId !== 0 && !validTileIds.has(tileId)) {
        return;
      }
      let targetMap;
      let targetFlipHRef;
      let targetFlipVRef;
      let targetSparseIndex = null;
      if (activeLayer === 'background') {
        const layer = backgroundLayers[activeBackgroundIndex];
        if (!layer) return;
        targetMap = layer.map;
        targetFlipHRef = layer.flipH;
        targetFlipVRef = layer.flipV;
        ensureSparseIndexArrays();
        targetSparseIndex = sparseIndexes.background[activeBackgroundIndex];
      } else if (activeLayer === 'front') {
        const layer = frontLayers[activeFrontIndex];
        if (!layer) return;
        targetMap = layer.map;
        targetFlipHRef = layer.flipH;
        targetFlipVRef = layer.flipV;
        ensureSparseIndexArrays();
        targetSparseIndex = sparseIndexes.front[activeFrontIndex];
      } else if (activeLayer === 'debug') {
        const previous = debugMap[row][col];
        if (tileId === DEBUG_TILE_IDS.PLAYER_SPAWN) {
          if (debugSpawnLocation) {
            debugMap[debugSpawnLocation.row][debugSpawnLocation.col] = 0;
          }
          debugSpawnLocation = { row, col };
        } else if (previous === DEBUG_TILE_IDS.PLAYER_SPAWN && tileId !== DEBUG_TILE_IDS.PLAYER_SPAWN) {
          debugSpawnLocation = null;
        }
        debugMap[row][col] = tileId;
        debugFlipH[row][col] = false;
        debugFlipV[row][col] = false;
        if (!debugSpawnLocation) {
          refreshDebugSpecialMarkers();
        }
        if (tileId !== 0) {
          addSparseCell(sparseIndexes.debug, row, col);
        } else {
          removeSparseCell(sparseIndexes.debug, row, col);
        }
        if (tileId !== 0) {
          updateBoundsOnAdd(row, col);
        } else if (!cellHasAnyTile(row, col)) {
          markBoundsDirtyIfBoundary(row, col);
        }
        markDirty();
        return;
      } else {
        targetMap = map;
        targetFlipHRef = flipH;
        targetFlipVRef = flipV;
        targetSparseIndex = sparseIndexes.foreground;
      }

      let tileToPlace = tileId;
      let flipHorizontal = brushFlipH;
      let flipVertical = brushFlipV;
      if (tileToPlace !== 0 && flipHorizontal && !flipVertical && HORIZONTAL_FLIP_REMAP.has(tileToPlace)) {
        tileToPlace = HORIZONTAL_FLIP_REMAP.get(tileToPlace);
        flipHorizontal = false;
      }

      const existingTile = targetMap[row][col];
      const nextFlipH = tileToPlace === 0 ? false : flipHorizontal;
      const nextFlipV = tileToPlace === 0 ? false : flipVertical;
      if (existingTile === tileToPlace &&
        targetFlipHRef[row][col] === nextFlipH &&
        targetFlipVRef[row][col] === nextFlipV) {
        return;
      }
      const hadAnyBefore = cellHasAnyTile(row, col);
      targetMap[row][col] = tileToPlace;
      if (tileToPlace === 0) {
        targetFlipHRef[row][col] = false;
        targetFlipVRef[row][col] = false;
      } else {
        targetFlipHRef[row][col] = nextFlipH;
        targetFlipVRef[row][col] = nextFlipV;
      }
      if (targetSparseIndex) {
        if (tileToPlace !== 0) {
          addSparseCell(targetSparseIndex, row, col);
        } else {
          removeSparseCell(targetSparseIndex, row, col);
        }
      }
      const hasAnyAfter = cellHasAnyTile(row, col);
      if (!hadAnyBefore && hasAnyAfter) {
        updateBoundsOnAdd(row, col);
      } else if (hadAnyBefore && !hasAnyAfter) {
        markBoundsDirtyIfBoundary(row, col);
      }
      markDirty();
    }


    function remapHorizontalFlips(targetMap, targetFlipH, targetFlipV) {
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const tileId = targetMap[row][col];
          if (!tileId) {
            targetFlipH[row][col] = false;
            targetFlipV[row][col] = false;
            continue;
          }
          if (targetFlipV[row][col]) {
            continue;
          }
          if (targetFlipH[row][col] && HORIZONTAL_FLIP_REMAP.has(tileId)) {
            targetMap[row][col] = HORIZONTAL_FLIP_REMAP.get(tileId);
            targetFlipH[row][col] = false;
          }
        }
      }
    }
    function pointerToTile(event) {
      const rect = canvas.getBoundingClientRect();
      const clientX = event.clientX ?? event.touches?.[0]?.clientX ?? 0;
      const clientY = event.clientY ?? event.touches?.[0]?.clientY ?? 0;
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      return worldToTile(x, y);
    }

    function normalizeFlipFlags() {
      remapHorizontalFlips(map, flipH, flipV);
      backgroundLayers.forEach((layer) => {
        remapHorizontalFlips(layer.map, layer.flipH, layer.flipV);
      });
      frontLayers.forEach((layer) => {
        remapHorizontalFlips(layer.map, layer.flipH, layer.flipV);
      });
    }


    function paintFromPointer(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX || event.touches?.[0]?.clientX || 0) - rect.left;
      const y = (event.clientY || event.touches?.[0]?.clientY || 0) - rect.top;
      const { col, row } = worldToTile(x, y);
      const tileId = getSelectedTile();
      if (tileId !== 0 && !validTileIds.has(tileId)) {
        return;
      }
      setTileAt(col, row, tileId);
    }
        function finalizeSelectionFromRect() {
      if (!selectionRect) {
        selection = null;
        updateMoveTargetLabel();
        requestRender();
        return;
      }
      let { startRow, startCol, endRow, endCol } = selectionRect;

      let minRow = Math.min(startRow, endRow);
      let maxRow = Math.max(startRow, endRow);
      let minCol = Math.min(startCol, endCol);
      let maxCol = Math.max(startCol, endCol);

      // マップ内にクランプ
      minRow = Math.max(0, Math.min(ROWS - 1, minRow));
      maxRow = Math.max(0, Math.min(ROWS - 1, maxRow));
      minCol = Math.max(0, Math.min(COLS - 1, minCol));
      maxCol = Math.max(0, Math.min(COLS - 1, maxCol));

      if (minRow > maxRow || minCol > maxCol) {
        selection = null;
        selectionRect = null;
        updateMoveTargetLabel();
        requestRender();
        return;
      }

      selection = { minRow, maxRow, minCol, maxCol };
      selectionRect = null;
      updateMoveTargetLabel();
      const w = maxCol - minCol + 1;
      const h = maxRow - minRow + 1;
      showToast(`${w}×${h} タイルを選択しました`);
      requestRender();
    }


        canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) {
        return;
      }
      mouseDown = true;

      if (activeTool === 'select') {
        const { col, row } = pointerToTile(event);
        isDraggingSelection = true;
        selectionRect = {
          startRow: row,
          startCol: col,
          endRow: row,
          endCol: col
        };
        requestRender();
      } else {
        paintFromPointer(event);
      }
    });

    window.addEventListener('mouseup', () => {
      if (activeTool === 'select' && isDraggingSelection) {
        finalizeSelectionFromRect();
      }
      mouseDown = false;
      isDraggingSelection = false;
    });

    canvas.addEventListener('mousemove', (event) => {
      if (!mouseDown) {
        return;
      }
      if (activeTool === 'select' && isDraggingSelection) {
        const { col, row } = pointerToTile(event);
        if (selectionRect) {
          selectionRect.endRow = row;
          selectionRect.endCol = col;
          requestRender();
        }
      } else {
        paintFromPointer(event);
      }
    });


        canvas.addEventListener('touchstart', (event) => {
      mouseDown = true;
      if (activeTool === 'select') {
        const { col, row } = pointerToTile(event);
        isDraggingSelection = true;
        selectionRect = {
          startRow: row,
          startCol: col,
          endRow: row,
          endCol: col
        };
        requestRender();
      } else {
        paintFromPointer(event);
      }
    }, { passive: true });

    canvas.addEventListener('touchmove', (event) => {
      if (!mouseDown) {
        return;
      }
      if (activeTool === 'select' && isDraggingSelection) {
        const { col, row } = pointerToTile(event);
        if (selectionRect) {
          selectionRect.endRow = row;
          selectionRect.endCol = col;
          requestRender();
        }
      } else {
        paintFromPointer(event);
      }
    }, { passive: true });

    window.addEventListener('touchend', () => {
      if (activeTool === 'select' && isDraggingSelection) {
        finalizeSelectionFromRect();
      }
      mouseDown = false;
      isDraggingSelection = false;
    });


    window.addEventListener('keydown', (event) => {
      if (event.repeat) {
        return;
      }
      if (event.key === 'Escape') {
        clearSelection(true);
        return;
      }
      if (event.key in keys) {
        keys[event.key] = true;
        event.preventDefault();
      }
      if (event.key in keys) {
        keys[event.key] = true;
        event.preventDefault();
      }
      if (event.key >= '0' && event.key <= '9') {
        const index = Number(event.key);
        const paletteItem = paletteItemById.get(index);
        if (paletteItem) {
          const selectedId = paletteItem.id;
          setSelectedTile(selectedId);
          const activeItems = getActivePaletteItems();
          const containsSelected = activeItems.some((item) => item.id === selectedId);
          if (!containsSelected && activePaletteKey !== 'all') {
            activePaletteKey = 'all';
            renderPaletteTabs();
          }
          buildPalette(getActivePaletteItems());
        }
      }
    });

    window.addEventListener('keyup', (event) => {
      if (event.key in keys) {
        keys[event.key] = false;
        event.preventDefault();
      }
    });

    if (isAutosaveAvailable() && typeof navigator.sendBeacon === 'function') {
      window.addEventListener('beforeunload', () => {
        if (!mapHasUnsavedChanges && !autosaveInFlight) {
          return;
        }
        try {
          const payload = JSON.stringify(exportMapData());
          const blob = new Blob([payload], { type: 'application/json' });
          navigator.sendBeacon(AUTOSAVE_ENDPOINT, blob);
        } catch (error) {
          console.warn('terrain-data.js の退避送信に失敗しました', error);
        }
      });
    }

    function sanitizeTileValue(value) {
      const tileId = Number(value);
      if (!Number.isFinite(tileId) || !validTileIds.has(tileId)) {
        return 0;
      }
      return tileId;
    }

    function clearAllMaps() {
      for (let row = 0; row < ROWS; row++) {
        const fgRow = map[row];
        const bgRow = backgroundMap[row];
        const frontRow = frontMap[row];
        const debugRow = debugMap[row];
        const fgFlipHRow = flipH[row];
        const fgFlipVRow = flipV[row];
        const bgFlipHRow = backgroundFlipH[row];
        const bgFlipVRow = backgroundFlipV[row];
        const frontFlipHRow = frontFlipH[row];
        const frontFlipVRow = frontFlipV[row];
        for (let col = 0; col < COLS; col++) {
          fgRow[col] = 0;
          bgRow[col] = 0;
          frontRow[col] = 0;
          debugRow[col] = 0;
          fgFlipHRow[col] = false;
          fgFlipVRow[col] = false;
          bgFlipHRow[col] = false;
          bgFlipVRow[col] = false;
          frontFlipHRow[col] = false;
          frontFlipVRow[col] = false;
          debugFlipH[row][col] = false;
          debugFlipV[row][col] = false;
        }
      }
      cachedBounds.minRow = 0;
      cachedBounds.maxRow = -1;
      cachedBounds.minCol = 0;
      cachedBounds.maxCol = -1;
      cachedBounds.dirty = false;
      rebuildAllSparseIndexes();
    }

    function importLayerData(targetMap, targetFlipH, targetFlipV, sourceMap, sourceFlipH, sourceFlipV, originRow, originCol, options = {}) {
      const ignoreFlipFlags = options?.ignoreFlipFlags === true;
      const rows = Array.isArray(sourceMap) ? sourceMap.length : 0;
      for (let r = 0; r < rows; r++) {
        const rowData = Array.isArray(sourceMap[r]) ? sourceMap[r] : [];
        const flipHRow = Array.isArray(sourceFlipH?.[r]) ? sourceFlipH[r] : [];
        const flipVRow = Array.isArray(sourceFlipV?.[r]) ? sourceFlipV[r] : [];
        for (let c = 0; c < rowData.length; c++) {
          const tileId = sanitizeTileValue(rowData[c]);
          const targetRow = originRow + r;
          const targetCol = originCol + c;
          if (targetRow < 0 || targetRow >= ROWS || targetCol < 0 || targetCol >= COLS) {
            continue;
          }
          targetMap[targetRow][targetCol] = tileId;
          if (targetFlipH) {
            targetFlipH[targetRow][targetCol] = ignoreFlipFlags ? false : !!flipHRow[c];
          }
          if (targetFlipV) {
            targetFlipV[targetRow][targetCol] = ignoreFlipFlags ? false : !!flipVRow[c];
          }
        }
      }
    }

    function applySparseLayer(entries, targetMap, targetFlipH, targetFlipV, originRow, originCol, options = {}) {
      const ignoreFlipFlags = options?.ignoreFlipFlags === true;
      if (!Array.isArray(entries)) {
        return false;
      }
      let applied = false;
      for (const entry of entries) {
        if (!Array.isArray(entry) || entry.length < 3) {
          continue;
        }
        const relRow = entry[0];
        const relCol = entry[1];
        const tileId = sanitizeTileValue(entry[2]);
        if (!Number.isFinite(relRow) || !Number.isFinite(relCol)) {
          continue;
        }
        const targetRow = originRow + Math.trunc(relRow);
        const targetCol = originCol + Math.trunc(relCol);
        if (targetRow < 0 || targetRow >= ROWS || targetCol < 0 || targetCol >= COLS) {
          continue;
        }
        const flags = Number.isFinite(entry[3]) ? entry[3] : 0;
        targetMap[targetRow][targetCol] = tileId;
        if (targetFlipH) {
          targetFlipH[targetRow][targetCol] = ignoreFlipFlags ? false : !!(flags & 1);
        }
        if (targetFlipV) {
          targetFlipV[targetRow][targetCol] = ignoreFlipFlags ? false : !!(flags & 2);
        }
        applied = true;
      }
      return applied;
    }

    function importMapData(data, options = {}) {
      const suppressAutosave = options?.suppressAutosave === true;
      if (!data) {
        throw new Error('無効なマップデータです');
      }

      if (suppressAutosave) {
        autosaveSuppressCount++;
      }

      let imported = false;
      try {
        clearAllMaps();

        if (Array.isArray(data)) {
          importLayerData(map, flipH, flipV, data, null, null, 0, 0);
          imported = true;
        } else {
          const originRow = Number.isFinite(data?.origin?.row) ? data.origin.row : 0;
          const originCol = Number.isFinite(data?.origin?.col) ? data.origin.col : 0;

          const applyLayerEntries = (layerDef, target) => {
            if (!layerDef || !Array.isArray(layerDef.entries)) return;
            layerDef.entries.forEach((entry) => {
              if (!Array.isArray(entry) || entry.length < 3) return;
              const relRow = Number(entry[0]) || 0;
              const relCol = Number(entry[1]) || 0;
              const value = Number(entry[2]) || 0;
              const targetRow = originRow + relRow;
              const targetCol = originCol + relCol;
              if (targetRow < 0 || targetRow >= ROWS || targetCol < 0 || targetCol >= COLS) return;
              target[targetRow][targetCol] = value;
            });
          };

          if (data.layers && typeof data.layers === 'object') {
            applyLayerEntries(data.layers.foreground, map);
            applyLayerEntries(data.layers.background, backgroundMap);
            applyLayerEntries(data.layers.front, frontMap);
            applyLayerEntries(data.layers.debug, debugMap);
            imported = true;
          }

          if (Array.isArray(data.map)) {
            importLayerData(
              map,
              flipH,
              flipV,
              data.map,
              data.mapFlipH,
              data.mapFlipV,
              originRow,
              originCol
            );
            imported = true;
          }
          if (Array.isArray(data.background)) {
            importLayerData(
              backgroundMap,
              backgroundFlipH,
              backgroundFlipV,
              data.background,
              data.backgroundFlipH,
              data.backgroundFlipV,
              originRow,
              originCol
            );
            imported = true;
          }
          if (Array.isArray(data.front)) {
            importLayerData(
              frontMap,
              frontFlipH,
              frontFlipV,
              data.front,
              data.frontFlipH,
              data.frontFlipV,
              originRow,
              originCol,
            );
            imported = true;
          }
          if (Array.isArray(data.debug)) {
            importLayerData(
              debugMap,
              debugFlipH,
              debugFlipV,
              data.debug,
              data.debugFlipH,
              data.debugFlipV,
              originRow,
              originCol,
              { ignoreFlipFlags: true }
            );
            imported = true;
          }
        }
      } finally {
        if (suppressAutosave) {
          autosaveSuppressCount = Math.max(0, autosaveSuppressCount - 1);
        }
      }

      if (imported) {
        refreshDebugSpecialMarkers();
        recalcBounds();
        rebuildAllSparseIndexes();
      }
      if (!suppressAutosave && imported) {
        markDirty();
      }
    }

    normalizeFlipFlags();
    rebuildAllSparseIndexes();
    applySavedCamera();

    if (saveHelpDontShow) {
      saveHelpDontShow.checked = !readBooleanPref(PREF_SHOW_SAVE_HELP_KEY, true);
    }
    if (readBooleanPref(PREF_SHOW_SAVE_HELP_KEY, true)) {
      setSaveHelpModalVisible(true);
    }

    if (initialTerrainMap) {
      try {
        importMapData(initialTerrainMap, { suppressAutosave: true });
        showToast('terrain.jsonを読み込みました');
      } catch (error) {
        console.error('terrain.json の読み込みに失敗しました', error);
        showToast('terrain.jsonの読み込みに失敗しました');
      }
    }

    function exportMapData() {
      normalizeFlipFlags();
      if (cachedBounds.dirty) {
        recalcBounds();
      }
      const minRow = cachedBounds.minRow;
      const maxRow = cachedBounds.maxRow;
      const minCol = cachedBounds.minCol;
      const maxCol = cachedBounds.maxCol;

      if (maxRow === -1) {
        return {
          version: 4,
          cols: 1,
          rows: 1,
          tileSize: TILE_SIZE,
          origin: { row: 0, col: 0 },
          map: [[0]],
          background: [],
          front: [],
          debug: [],
          layers: {},
          tiles: []
        };
      }

      const trimmedRows = maxRow - minRow + 1;
      const trimmedCols = maxCol - minCol + 1;
      const usedTileIds = new Set();

      const buildEntries = (source) => {
        const entries = [];
        for (let r = minRow; r <= maxRow; r++) {
          for (let c = minCol; c <= maxCol; c++) {
            const value = source[r]?.[c] || 0;
            if (!value) continue;
            entries.push([r - minRow, c - minCol, value]);
            usedTileIds.add(value);
          }
        }
        return entries;
      };

      const buildEntriesFromLayers = (layers) => {
        const entries = [];
        for (let r = minRow; r <= maxRow; r++) {
          for (let c = minCol; c <= maxCol; c++) {
            let value = 0;
            for (const layer of layers) {
              const tileValue = layer?.map?.[r]?.[c] || 0;
              if (tileValue) {
                value = tileValue;
              }
            }
            if (!value) continue;
            entries.push([r - minRow, c - minCol, value]);
            usedTileIds.add(value);
          }
        }
        return entries;
      };

      const layersPayload = {
        foreground: { entries: buildEntries(map) },
        background: { entries: buildEntriesFromLayers(backgroundLayers) },
        front: { entries: buildEntriesFromLayers(frontLayers) },
        debug: { entries: buildEntries(debugMap) }
      };

      const tileDefinitions = Array.from(usedTileIds)
        .sort((a, b) => a - b)
        .map((id) => {
          const def = paletteItemById.get(id);
          return { id, assetName: def?.assetName || null, name: def?.name || null };
        });

      const sliceLayer = (source) => {
        const out = [];
        for (let r = minRow; r <= maxRow; r++) {
          const row = [];
          for (let c = minCol; c <= maxCol; c++) {
            row.push(source?.[r]?.[c] || 0);
          }
          out.push(row);
        }
        return out;
      };

      const sliceLayerFromLayers = (layers) => {
        const out = [];
        for (let r = minRow; r <= maxRow; r++) {
          const row = [];
          for (let c = minCol; c <= maxCol; c++) {
            let value = 0;
            for (const layer of layers) {
              const tileValue = layer?.map?.[r]?.[c] || 0;
              if (tileValue) {
                value = tileValue;
              }
            }
            row.push(value);
          }
          out.push(row);
        }
        return out;
      };

      const composeCombinedMap = () => {
        const out = [];
        for (let r = minRow; r <= maxRow; r++) {
          const row = [];
          for (let c = minCol; c <= maxCol; c++) {
            let value = 0;
            for (const layer of backgroundLayers) {
              const tileValue = layer?.map?.[r]?.[c] || 0;
              if (tileValue) {
                value = tileValue;
              }
            }
            const fgValue = map?.[r]?.[c] || 0;
            if (fgValue) {
              value = fgValue;
            }
            for (const layer of frontLayers) {
              const tileValue = layer?.map?.[r]?.[c] || 0;
              if (tileValue) {
                value = tileValue;
              }
            }
            row.push(value);
          }
          out.push(row);
        }
        return out;
      };

      return {
        version: 4,
        cols: trimmedCols,
        rows: trimmedRows,
        tileSize: TILE_SIZE,
        origin: { row: minRow, col: minCol },
        map: composeCombinedMap(),
        background: sliceLayerFromLayers(backgroundLayers),
        front: sliceLayerFromLayers(frontLayers),
        debug: sliceLayer(debugMap),
        layers: layersPayload,
        tiles: tileDefinitions
      };
    }


    function extractJsonObjectFromAssignment(text, identifier) {
      if (typeof text !== 'string' || !identifier) {
        return null;
      }
      const keywordIndex = text.indexOf(identifier);
      if (keywordIndex === -1) {
        return null;
      }
      const equalsIndex = text.indexOf('=', keywordIndex);
      if (equalsIndex === -1) {
        return null;
      }
      let startIndex = text.indexOf('{', equalsIndex);
      if (startIndex === -1) {
        return null;
      }
      let depth = 0;
      let inString = false;
      let stringQuote = '';
      for (let i = startIndex; i < text.length; i++) {
        const char = text[i];
        if (inString) {
          if (char === '\\' && i + 1 < text.length) {
            i++;
            continue;
          }
          if (char === stringQuote) {
            inString = false;
          }
          continue;
        }
        if (char === '"' || char === '\'') {
          inString = true;
          stringQuote = char;
          continue;
        }
        if (char === '{') {
          depth++;
        } else if (char === '}') {
          depth--;
          if (depth === 0) {
            return text.slice(startIndex, i + 1);
          }
        }
      }
      return null;
    }

    function parseMapFileContent(text, isJsFile) {
      if (typeof text !== 'string' || !text.trim()) {
        throw new Error('ファイル内容が空です');
      }
      if (!isJsFile) {
        return JSON.parse(text);
      }
      const jsonText = extractJsonObjectFromAssignment(text, 'RAFT_MAP_DATA');
      if (jsonText) {
        return JSON.parse(jsonText);
      }
      throw new Error('RAFT_MAP_DATA を含むマップデータが見つかりませんでした');
    }

    uploadButton.addEventListener('click', () => {
      uploadInput.value = '';
      uploadInput.click();
    });

    uploadInput.addEventListener('change', (event) => {
      const file = event.target.files?.[0];
      if (!file) {
        return;
      }
      const isJsFile = /\.js$/i.test(file.name);
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const text = typeof reader.result === 'string' ? reader.result : '';
          const parsed = parseMapFileContent(text, isJsFile);
          importMapData(parsed);
          showToast('マップを読み込みました');
        } catch (error) {
          console.error(error);
          showToast('マップの読み込みに失敗しました');
        }
      };
      reader.readAsText(file, 'utf-8');
    });

    downloadButton.addEventListener('click', async () => {
      try {
        const payload = exportMapData();
        const json = JSON.stringify(payload, null, 2);
        const jsContent = `window.RAFT_TERRAIN_DATA = window.FALLBACK_TERRAIN_DATA = ${json};\n`;

        if (typeof window.showSaveFilePicker === 'function') {
          const ensureWritable = async (existingHandle, pickerOptions) => {
            let handle = existingHandle;
            try {
              if (handle && handle.queryPermission) {
                const perm = await handle.queryPermission({ mode: 'readwrite' });
                if (perm !== 'granted' && handle.requestPermission) {
                  const request = await handle.requestPermission({ mode: 'readwrite' });
                  if (request !== 'granted') {
                    handle = null;
                  }
                }
              }
            } catch (_) {
              handle = null;
            }
            if (!handle || typeof handle.createWritable !== 'function') {
              handle = await window.showSaveFilePicker(pickerOptions);
            }
            return handle;
          };

          let jsonHandle = null;
          try {
            jsonHandle = await readHandleFromDb('terrain_json');
          } catch (_) {
            jsonHandle = null;
          }
          jsonHandle = await ensureWritable(jsonHandle, {
            suggestedName: 'terrain.json',
            types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
          });
          const jsonWritable = await jsonHandle.createWritable();
          await jsonWritable.write(new Blob([json], { type: 'application/json' }));
          await jsonWritable.close();
          await writeHandleToDb('terrain_json', jsonHandle);

          let jsHandle = null;
          try {
            jsHandle = await readHandleFromDb('terrain_js');
          } catch (_) {
            jsHandle = null;
          }
          jsHandle = await ensureWritable(jsHandle, {
            suggestedName: 'terrain-data.js',
            types: [{ description: 'JavaScript', accept: { 'application/javascript': ['.js'] } }]
          });
          const jsWritable = await jsHandle.createWritable();
          await jsWritable.write(new Blob([jsContent], { type: 'application/javascript' }));
          await jsWritable.close();
          await writeHandleToDb('terrain_js', jsHandle);

          showToast('terrain.json と terrain-data.js を保存しました');
          return;
        }

        const blob = new Blob([jsContent], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = 'terrain-data.js';
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
        showToast('terrain-data.js を出力しました');
      } catch (error) {
        if (error && error.name === 'AbortError') {
          showToast('保存をキャンセルしました');
          return;
        }
        console.error(error);
        showToast('ダウンロードに失敗しました（保存先を再選択してください）');
      }
    });

    function getDarkTileBitmap(srcImg, tileSize, key, brightness) {
      if (!srcImg) return null;
      if (!(brightness < 0.999)) {
        return srcImg;
      }
      const cached = darkTileCache[key];
      if (cached) return cached;
      const out = document.createElement('canvas');
      out.width = tileSize;
      out.height = tileSize;
      const octx = out.getContext('2d');
      octx.imageSmoothingEnabled = false;
      octx.clearRect(0, 0, tileSize, tileSize);
      octx.drawImage(srcImg, 0, 0, tileSize, tileSize);
      const mask = document.createElement('canvas');
      mask.width = tileSize;
      mask.height = tileSize;
      const mctx = mask.getContext('2d');
      mctx.imageSmoothingEnabled = false;
      const clamped = Math.max(0, Math.min(1, brightness));
      const overlayAlpha = 1 - clamped;
      if (overlayAlpha > 0) {
        mctx.clearRect(0, 0, tileSize, tileSize);
        mctx.fillStyle = `rgba(0,0,0,${overlayAlpha})`;
        mctx.fillRect(0, 0, tileSize, tileSize);
        mctx.globalCompositeOperation = 'destination-in';
        mctx.drawImage(srcImg, 0, 0, tileSize, tileSize);
        mctx.globalCompositeOperation = 'source-over';
        octx.globalCompositeOperation = 'multiply';
        octx.drawImage(mask, 0, 0);
        octx.globalCompositeOperation = 'source-over';
      }
      darkTileCache[key] = out;
      return out;
    }
    function getTileRenderImage(srcImg, tileId, flipHorizontal, flipVertical) {
      if (!srcImg || !srcImg.complete || srcImg.naturalWidth === 0) {
        return null;
      }
      if (!flipHorizontal && !flipVertical) {
        return srcImg;
      }
      const srcKey = srcImg.src || `tile_${tileId}`;
      const cacheKey = `${tileId}_${flipHorizontal ? 1 : 0}${flipVertical ? 1 : 0}_${srcKey}`;
      if (flippedTileCache[cacheKey]) {
        return flippedTileCache[cacheKey];
      }
      const out = document.createElement('canvas');
      out.width = TILE_SIZE;
      out.height = TILE_SIZE;
      const octx = out.getContext('2d');
      octx.imageSmoothingEnabled = false;
      octx.translate(TILE_SIZE / 2, TILE_SIZE / 2);
      octx.scale(flipHorizontal ? -1 : 1, flipVertical ? -1 : 1);
      octx.drawImage(srcImg, -TILE_SIZE / 2, -TILE_SIZE / 2, TILE_SIZE, TILE_SIZE);
      flippedTileCache[cacheKey] = out;
      return out;
    }
        function drawSelectionOverlay() {
      const region = selectionRect
        ? {
            minRow: Math.min(selectionRect.startRow, selectionRect.endRow),
            maxRow: Math.max(selectionRect.startRow, selectionRect.endRow),
            minCol: Math.min(selectionRect.startCol, selectionRect.endCol),
            maxCol: Math.max(selectionRect.startCol, selectionRect.endCol),
          }
        : selection;

      if (!region) return;

      let { minRow, maxRow, minCol, maxCol } = region;
      minRow = Math.max(0, Math.min(ROWS - 1, minRow));
      maxRow = Math.max(0, Math.min(ROWS - 1, maxRow));
      minCol = Math.max(0, Math.min(COLS - 1, minCol));
      maxCol = Math.max(0, Math.min(COLS - 1, maxCol));

      const x = minCol * TILE_SIZE;
      const y = minRow * TILE_SIZE;
      const w = (maxCol - minCol + 1) * TILE_SIZE;
      const h = (maxRow - minRow + 1) * TILE_SIZE;

      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = '#4f9dff';
      ctx.fillRect(x, y, w, h);
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = '#9ac8ff';
      ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
      ctx.restore();
    }


    function drawGrid(options = {}) {
      const showGridLines = options.showGridLines !== false;
      const renderBackground = options.renderBackground !== false;
      const renderFront = options.renderFront !== false;
      const activeOnly = options.activeOnly === true;
      const renderOverlays = options.renderOverlays !== false;
      const viewWidth = canvas.width / RENDER_SCALE;
      const viewHeight = canvas.height / RENDER_SCALE;
      const startCol = Math.floor(camera.x / TILE_SIZE);
      const endCol = Math.min(COLS - 1, Math.ceil((camera.x + viewWidth) / TILE_SIZE));
      const startRow = Math.floor(camera.y / TILE_SIZE);
      const endRow = Math.min(ROWS - 1, Math.ceil((camera.y + viewHeight) / TILE_SIZE));
      const layerAlpha = {
    foreground: { map: 1.0, front: 0.3, background: 0.2, debug: 0.2 },
    front: { map: 0.3, front: 1.0, background: 0.2, debug: 0.2 },
    background: { map: 0.3, front: 0.3, background: 1.0, debug: 0.2 },
    debug: { map: 0.3, front: 0.3, background: 0.3, debug: 1.0 },
  }[activeLayer] || { map: 1.0, front: 1.0, background: 1.0, debug: 1.0 };

      ctx.save();
      ctx.scale(RENDER_SCALE, RENDER_SCALE);
      ctx.translate(-camera.x, -camera.y);
      ctx.fillStyle = '#060915';
      ctx.fillRect(camera.x, camera.y, viewWidth, viewHeight);

      const drawSparseLayer = (index, drawCell) => {
        index.rows.forEach((rowSet, row) => {
          if (row < startRow || row > endRow) {
            return;
          }
          rowSet.forEach((col) => {
            if (col < startCol || col > endCol) {
              return;
            }
            drawCell(row, col);
          });
        });
      };

      if (renderBackground && (!activeOnly || activeLayer === 'background')) {
        backgroundLayers.forEach((layer, layerIndex) => {
          if (activeOnly && layerIndex !== activeBackgroundIndex) {
            return;
          }
          const layerIndexRef = sparseIndexes.background[layerIndex];
          if (!layerIndexRef) return;
          ctx.globalAlpha = layerAlpha.background;
          drawSparseLayer(layerIndexRef, (row, col) => {
            const bgTile = layer.map[row][col];
            if (!bgTile) return;
            const drawX = col * TILE_SIZE;
            const drawY = row * TILE_SIZE;
            const bgImage = getTileImageById(bgTile);
            if (bgImage && bgImage.complete) {
              const flipHorizontal = layer.flipH[row][col];
              const flipVertical = layer.flipV[row][col];
              const renderImage = getTileRenderImage(bgImage, bgTile, flipHorizontal, flipVertical);
              if (renderImage) {
                ctx.drawImage(renderImage, drawX, drawY, TILE_SIZE, TILE_SIZE);
              }
            } else {
              ctx.fillStyle = 'rgba(70, 100, 160, 0.35)';
              ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
            }
          });
          ctx.globalAlpha = 1;
        });
      }

      if (!activeOnly || activeLayer === 'foreground') {
        ctx.globalAlpha = layerAlpha.map;
        drawSparseLayer(sparseIndexes.foreground, (row, col) => {
          const tile = map[row][col];
          if (!tile) return;
          const drawX = col * TILE_SIZE;
          const drawY = row * TILE_SIZE;
        let image = getTileImageById(tile);
          if (tile === 34 && window.poisonImages && window.poisonImages.length) {
            const __frame = window.poisonImages[window.poisonAnim.index];
            if (__frame && __frame.complete && __frame.naturalWidth > 0) {
              image = __frame;
            }
          }
          if (image && image.complete) {
            const flipHorizontal = flipH[row][col];
            const flipVertical = flipV[row][col];
            const renderImage = getTileRenderImage(image, tile, flipHorizontal, flipVertical);
            if (renderImage) {
              ctx.drawImage(renderImage, drawX, drawY, TILE_SIZE, TILE_SIZE);
            }
          } else {
            ctx.fillStyle = '#3c5aa6';
            ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
          }
        });
        ctx.globalAlpha = 1;
      }

      if (renderFront && (!activeOnly || activeLayer === 'front')) {
        ctx.globalAlpha = layerAlpha.front;
        frontLayers.forEach((layer, layerIndex) => {
          if (activeOnly && layerIndex !== activeFrontIndex) {
            return;
          }
          const layerIndexRef = sparseIndexes.front[layerIndex];
          if (!layerIndexRef) return;
          drawSparseLayer(layerIndexRef, (row, col) => {
            const frontTile = layer.map[row][col];
            if (!frontTile) return;
            const drawX = col * TILE_SIZE;
            const drawY = row * TILE_SIZE;
          const frontImage = getTileImageById(frontTile);
            if (frontImage && frontImage.complete) {
              const flipHorizontal = layer.flipH[row][col];
              const flipVertical = layer.flipV[row][col];
              const renderImage = getTileRenderImage(frontImage, frontTile, flipHorizontal, flipVertical);
              if (renderImage) {
                ctx.drawImage(renderImage, drawX, drawY, TILE_SIZE, TILE_SIZE);
              }
            } else {
              ctx.fillStyle = 'rgba(120, 180, 255, 0.55)';
              ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
            }
          });
        });
        ctx.globalAlpha = 1;
      }

      if (renderOverlays && (!activeOnly || activeLayer === 'debug') && activeLayer === 'debug') {
        drawSparseLayer(sparseIndexes.debug, (row, col) => {
          const debugTile = debugMap[row][col];
          if (!debugTile) return;
          const drawX = col * TILE_SIZE;
          const drawY = row * TILE_SIZE;
          const label = HELP_TILE_MESSAGES[debugTile] || `ID ${debugTile}`;
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = 'rgba(90, 150, 255, 0.35)';
          ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = 'rgba(90, 150, 255, 0.7)';
          ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#dfe9ff';
          ctx.font = '600 12px "Segoe UI", sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(label, drawX + TILE_SIZE / 2, drawY + TILE_SIZE / 2);
          ctx.restore();
        });
      }

      if (showGridLines) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.lineWidth = 1;
        for (let col = startCol; col <= endCol; col++) {
          const x = col * TILE_SIZE;
          ctx.beginPath();
          ctx.moveTo(x, startRow * TILE_SIZE);
          ctx.lineTo(x, (endRow + 1) * TILE_SIZE);
          ctx.stroke();
        }
        for (let row = startRow; row <= endRow; row++) {
          const y = row * TILE_SIZE;
          ctx.beginPath();
          ctx.moveTo(startCol * TILE_SIZE, y);
          ctx.lineTo((endCol + 1) * TILE_SIZE, y);
          ctx.stroke();
        }
      }
      if (renderOverlays) {
        drawSelectionOverlay();
      }

      ctx.restore();
    }

    function loop() {
      const now = performance.now();
      const cameraMoved = updateCamera();
      let shouldRender = needsRender || cameraMoved;
      const isMoving = cameraMoved ||
        keys.w || keys.a || keys.s || keys.d ||
        keys.W || keys.A || keys.S || keys.D ||
        keys.Shift;
      const isUIResizing = isResizingPalette;
      const isUIBusy = isMoving || isDraggingPalette || isResizingPalette;

      if (!isUIResizing && window.poisonImages && window.poisonImages.length) {
        if (now - window.poisonAnim.lastTime >= window.poisonAnim.interval) {
          window.poisonAnim.lastTime = now;
          window.poisonAnim.index = (window.poisonAnim.index + 1) % window.poisonImages.length;
          shouldRender = true;
        }
      }

      const forceInteractiveRender = mouseDown || isDraggingSelection || isUIBusy;
      document.body.classList.toggle('moving', isMoving);
      const targetFps = isUIBusy ? 30 : RENDER_MAX_FPS;
      if (!isUIResizing && shouldRender && (forceInteractiveRender || now - lastRenderTime >= 1000 / targetFps)) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
        drawGrid({
          showGridLines: !isUIBusy,
          renderBackground: true,
          renderFront: true,
          activeOnly: isUIBusy,
          renderOverlays: !isUIBusy || activeLayer === 'debug'
        });
        needsRender = false;
        lastRenderTime = now;
      }

      requestAnimationFrame(loop);
    }
    loop();
  }
  (function bootstrapEditor() {
  function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(script);
      });
    }

    function loadAssetMap() {
      return loadScript('assets-base64.js?v=' + Date.now())
        .then(() => {
          const assets = (typeof window.ASSETS_BASE64 !== 'undefined') ? window.ASSETS_BASE64 : {};
          delete window.ASSETS_BASE64;
          return assets;
        })
        .catch((error) => {
          console.warn('assets-base64.js の読み込みに失敗しました。空のアセットマップを使用します。', error);
          return {};
        });
    }

    function loadAutosaveFromStorage() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return null;
      }
      if (!readBooleanPref(PREF_USE_LOCAL_AUTOSAVE_ON_LOAD_KEY, true)) {
        return null;
      }
      const stored = window.localStorage.getItem(AUTOSAVE_STORAGE_KEY);
      if (!stored) {
        return null;
      }
      try {
        const parsed = JSON.parse(stored);
        console.info('ローカル自動保存データを使用します。');
        return parsed;
      } catch (error) {
        console.warn('ローカル自動保存データの読み込みに失敗しました。破棄します。', error);
        try {
          window.localStorage.removeItem(AUTOSAVE_STORAGE_KEY);
        } catch (_) {
          /* noop */
        }
        return null;
      }
    }

    function loadTerrainData() {
      const cacheBust = '?v=' + Date.now();
      // まず terrain-data.js を試し、だめなら terrain.json にフォールバック
      return loadScript('terrain-data.js' + cacheBust)
        .then(() => {
          const mapData = (typeof window.RAFT_TERRAIN_DATA !== 'undefined')
            ? window.RAFT_TERRAIN_DATA
            : (typeof window.RAFT_MAP_DATA !== 'undefined' ? window.RAFT_MAP_DATA : null);
          delete window.RAFT_TERRAIN_DATA;
          delete window.RAFT_MAP_DATA;
          if (mapData) {
            console.log('terrain-data.js をエディタに読み込みました。');
            return mapData;
          }
          throw new Error('terrain-data.js にマップデータが見つかりませんでした');
        })
        .catch((scriptError) => {
          console.warn('terrain-data.js の読み込みに失敗しました。terrain.json を試みます。', scriptError);
          return fetch('terrain.json' + cacheBust, { cache: 'no-store' })
            .then((response) => {
              if (!response.ok) {
                throw new Error(`Failed to fetch terrain.json: ${response.status}`);
              }
              return response.json();
            })
            .then((data) => {
              console.log('terrain.json をエディタに読み込みました。');
              return data;
            })
            .catch((error) => {
              console.warn('terrain.json の読み込みにも失敗しました。空のマップを使用します。', error);
              return null;
            });
        });
    }

    Promise.all([loadAssetMap(), loadTerrainData()])
      .then(([assetMap, terrain]) => {
        const autosavedTerrain = loadAutosaveFromStorage();
        const terrainToUse = terrain || autosavedTerrain;
        initEditor(assetMap, terrainToUse);
      })
      .catch((error) => {
        console.error('エディタ初期化中にエラーが発生しました。空の設定で起動します。', error);
        initEditor({}, null);
      });
  })();
  </script>



<script id="inline-assets-fallback">
// Inline fallback for assets-base64.js (when 404/MIME mismatch)
// We only define this if window.ASSET_MAP is not set by external script.
</script>
</body>
</html>
<script>
if (typeof loadAssetMap !== 'function') {
  window.loadAssetMap = function(){
    if (window.ASSET_MAP) return Promise.resolve(window.ASSET_MAP);
    console.warn('assets-base64.js を読み込まずデフォルトのASSET_MAPを使用');
    window.ASSET_MAP = {};
    return Promise.resolve(window.ASSET_MAP);
  };
}
</script>
